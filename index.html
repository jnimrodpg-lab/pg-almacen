<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>TIENDAS PG ‚Ä¢ Localizador (PRO)</title>

<style>
  :root{
    --bg:#f6f6f6; --card:#ffffff; --text:#111827; --muted:#6b7280;
    --border:#e5e7eb; --primary:#2563eb; --danger:#dc2626;
    --warn:#f59e0b; --ok:#16a34a; --shadow:0 10px 25px rgba(0,0,0,.08);
    --radius:14px;
  }
  *{ box-sizing:border-box; }
  body{ margin:0; font-family: Arial, sans-serif; background:var(--bg); color:var(--text); padding:20px; }

  body.dark{
    --bg:#0b1220; --card:#0f172a; --text:#e5e7eb; --muted:#94a3b8;
    --border:#1f2937; --shadow:0 10px 25px rgba(0,0,0,.35);
  }

  .topbar{
    max-width:1200px; margin:0 auto 16px auto;
    display:flex; align-items:center; justify-content:space-between; gap:12px;
  }
  .brand{ display:flex; align-items:center; gap:12px; }
  .logoMark{
    width:44px;height:44px;border-radius:14px;
    background: linear-gradient(135deg, #111827, #374151);
    box-shadow: var(--shadow); position:relative; overflow:hidden;
  }
  .logoMark::before,.logoMark::after{
    content:""; position:absolute; top:10px; width:10px; height:24px;
    border-radius:6px; background: rgba(255,255,255,.85); opacity:.9;
  }
  .logoMark::before{ left:12px; } .logoMark::after{ right:12px; }
  .logoBase{
    position:absolute; left:10px; right:10px; bottom:8px;
    height:4px; border-radius:999px; background: rgba(255,255,255,.75);
  }
  .brandText{ display:flex; flex-direction:column; line-height:1.05; }
  .brandText .title{ font-size:18px; font-weight:900; letter-spacing:.5px; margin:0; }
  .brandText .subtitle{ font-size:12px; color:var(--muted); margin-top:4px; }
  .brandText .tag{
    display:inline-flex; align-items:center; gap:6px;
    margin-top:6px; font-size:11px;
    border:1px solid var(--border); background:var(--card);
    padding:6px 10px; border-radius:999px; width:max-content;
  }

  .topActions{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
  .toggle{
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    border-radius:999px;
    padding:10px 12px;
    cursor:pointer;
    box-shadow:0 6px 18px rgba(0,0,0,.05);
    font-size:13px;
    font-weight:800;
    display:inline-flex; align-items:center; gap:8px;
  }
  .toggle.primary{
    border-color: rgba(37,99,235,.35);
    box-shadow: 0 0 0 4px rgba(37,99,235,.08);
  }
  .status{
    display:flex; align-items:center; gap:8px;
    padding:10px 12px; border:1px solid var(--border);
    border-radius:999px; background:var(--card);
    box-shadow:0 6px 18px rgba(0,0,0,.05);
    white-space:nowrap; font-size:13px; color:var(--muted);
  }
  .dot{ width:10px;height:10px;border-radius:999px;background:var(--warn); }
  .dot.ok{ background:var(--ok); } .dot.bad{ background:var(--danger); }

  .layout{
    max-width:1200px; margin:0 auto; display:grid;
    grid-template-columns: 1.1fr .9fr; gap:16px; align-items:start;
  }
  @media (max-width: 980px){
    .layout{ grid-template-columns:1fr; }
    .sticky{ position:static !important; }
  }

  .card{
    background:var(--card); border:1px solid var(--border);
    border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden;
  }
  .card-header{
    padding:14px 14px 10px 14px; border-bottom:1px solid var(--border);
    display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  .card-header h2{ font-size:14px; margin:0; }
  .meta{ font-size:12px; color:var(--muted); }

  .controls{ padding:14px; display:grid; gap:10px; }
  .search input{
    width:100%; padding:12px; font-size:15px;
    border:1px solid var(--border); border-radius:12px; outline:none;
    background:var(--card); color:var(--text);
  }
  .search input:focus{
    border-color: rgba(37, 99, 235, .6);
    box-shadow: 0 0 0 4px rgba(37,99,235,.12);
  }

  .btnrow{ display:flex; gap:10px; flex-wrap:wrap; }
  .btn{
    flex:1; min-width:140px; border:none; border-radius:12px;
    padding:12px; font-size:14px; cursor:pointer; color:#fff;
    display:flex; align-items:center; justify-content:center; gap:8px;
    font-weight:900;
  }
  .btn.primary{ background:var(--primary); }
  .btn.danger{ background:var(--danger); }
  .btn.dark{ background:#111827; }
  body.dark .btn.dark{ background:#334155; }

  .chiprow{ display:flex; gap:8px; flex-wrap:wrap; }
  .chip{
    border:1px solid var(--border);
    background:var(--card); color:var(--text);
    border-radius:999px;
    padding:8px 10px;
    font-size:12px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:8px;
    user-select:none;
  }
  .chip .badge{
    font-size:11px;
    padding:3px 8px;
    border-radius:999px;
    border:1px solid var(--border);
    background:#f9fafb;
    color:var(--muted);
  }
  body.dark .chip .badge{ background:#0b1220; }
  .chip.active{
    border-color: rgba(37,99,235,.35);
    box-shadow: 0 0 0 4px rgba(37,99,235,.10);
  }
  .chip.active .badge{
    border-color: rgba(37,99,235,.35);
    background: rgba(37,99,235,.08);
    color: #1f3b8f;
  }
  body.dark .chip.active .badge{ color:#93c5fd; }

  .hint{ font-size:12px; color:var(--muted); line-height:1.4; }

  .result-card{
    margin-top:6px; padding:12px; border:1px dashed var(--border);
    border-radius:12px; background:rgba(0,0,0,.02); display:none;
  }
  body.dark .result-card{ background:rgba(255,255,255,.03); }
  .result-title{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .bigloc{ margin-top:8px; font-size:18px; font-weight:900; letter-spacing:.2px; }
  .sub{ margin-top:6px; font-size:12px; color:var(--muted); }

  .kv{ margin-top:10px; display:grid; gap:8px; }
  .kv-row{
    display:flex; justify-content:space-between; gap:10px;
    padding:10px 12px; border:1px solid var(--border);
    border-radius:12px; background:var(--card); font-size:12px;
  }
  .kv-row b{ color:var(--text); }
  .kv-row span{ color:var(--muted); text-align:right; }

  .picker{ margin-top:10px; display:flex; gap:10px; align-items:center; }
  .picker button{
    border:1px solid var(--border); background:var(--card); color:var(--text);
    border-radius:12px; padding:10px 12px; cursor:pointer;
    flex:1; min-width:120px; font-weight:900;
  }
  .picker button:disabled{ opacity:.45; cursor:not-allowed; }
  .picker .counter{
    padding:10px 12px; border:1px solid var(--border);
    background:var(--card); border-radius:12px; color:var(--muted);
    font-size:12px; white-space:nowrap;
  }

  .table-wrap{ border-top:1px solid var(--border); }
  .table-scroll{ max-height: 520px; overflow:auto; }
  table{ width:100%; border-collapse:collapse; font-size:13px; }
  thead th{
    position:sticky; top:0; background:#111827; color:#fff;
    text-align:left; padding:10px; z-index:2;
  }
  tbody td{ padding:10px; border-bottom:1px solid var(--border); vertical-align:top; }
  tbody tr:nth-child(even){ background:rgba(0,0,0,.02); }
  body.dark tbody tr:nth-child(even){ background:rgba(255,255,255,.03); }
  tbody tr.active{
    background:#fff7ed !important;
    outline:2px solid rgba(245, 158, 11, .35);
  }
  body.dark tbody tr.active{ background:rgba(245, 158, 11, .12) !important; }

  .sticky{ position: sticky; top: 20px; }
  #isoWrap{ padding:14px; }
  #isoMap{
    width:100%;
    height:420px;
    border:1px solid var(--border);
    border-radius:12px;
    background:var(--card);
    display:block;
    touch-action:none;
  }

  .iso-zone{ transition:.18s; }
  .iso-zone.z1{ fill:rgba(20,184,166,.10); stroke:rgba(20,184,166,.55); }
  .iso-zone.z2{ fill:rgba(45,212,191,.10); stroke:rgba(45,212,191,.55); }
  .iso-zone.z3{ fill:rgba(94,234,212,.10); stroke:rgba(94,234,212,.55); }
  .iso-zone.a1{ fill:rgba(147,197,253,.10); stroke:rgba(147,197,253,.55); }
  body.dark .iso-zone.z1{ fill:rgba(20,184,166,.06); stroke:rgba(20,184,166,.45); }
  body.dark .iso-zone.z2{ fill:rgba(45,212,191,.06); stroke:rgba(45,212,191,.45); }
  body.dark .iso-zone.z3{ fill:rgba(94,234,212,.06); stroke:rgba(94,234,212,.45); }
  body.dark .iso-zone.a1{ fill:rgba(147,197,253,.06); stroke:rgba(147,197,253,.45); }

  .iso-zone.mainHL{ fill:rgba(251,191,36,.25) !important; stroke:#f97316 !important; stroke-width:3; }
  .iso-zone.storeHL{ fill:rgba(34,197,94,.18) !important; stroke:#16a34a !important; stroke-width:3; }
  .iso-zone.selected{ stroke:#2563eb !important; stroke-width:3.3; fill:rgba(37,99,235,.10) !important; }

  .rack{ cursor:pointer; transition:.18s; }
  .rack.dim{ opacity:.25; }
  .rack .post{ stroke:#64748b; stroke-width:2.3; stroke-linecap:round; }
  .rack .shelfTop{ fill:#cbd5e1; stroke:#64748b; stroke-width:1; }
  .rack .shelfFront{ fill:#94a3b8; }
  .rack .shelfRight{ fill:#a3b3c8; }

  body.dark .rack .post{ stroke:#94a3b8; }
  body.dark .rack .shelfTop{ fill:#243045; stroke:#94a3b8; }
  body.dark .rack .shelfFront{ fill:#1f2a3d; }
  body.dark .rack .shelfRight{ fill:#22314b; }

  .rack.mainHL .post{ stroke:#f97316; }
  .rack.mainHL .shelfTop{ fill:#fef3c7; stroke:#f97316; }
  .rack.mainHL .shelfFront{ fill:#fbbf24; }
  .rack.mainHL .shelfRight{ fill:#f59e0b; }

  .rack.storeHL .post{ stroke:#16a34a; }
  .rack.storeHL .shelfTop{ fill:#dcfce7; stroke:#16a34a; }
  .rack.storeHL .shelfFront{ fill:#86efac; }
  .rack.storeHL .shelfRight{ fill:#22c55e; }

  .rack.hoverHL .post{ stroke:#2563eb; }
  .rack.hoverHL .shelfTop{ fill:rgba(37,99,235,.15); stroke:#2563eb; }

  .rack.selected .post{ stroke:#2563eb; }
  .rack.selected .shelfTop{ stroke:#2563eb; stroke-width:1.6; fill:rgba(37,99,235,.14); }

  /* ===== Vista Estante Isom√©trica ===== */
  .shelfIsoWrap{
    width:100%;
    border:1px solid var(--border);
    border-radius:12px;
    background:var(--card);
    overflow:hidden;
  }
  .shelfIsoTopbar{
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    font-size:12px;
    color:var(--muted);
  }
  .shelfIsoSvg{
    width:100%;
    height:260px;
    display:block;
  }

  /* ===== Editor sticky top ===== */
  .editorTop{
    position: sticky;
    top: 0;
    z-index: 20;
    background: var(--card);
    border-bottom: 1px solid var(--border);
    padding: 12px 14px;
    display:none;
  }
  .editorTop.on{ display:block; }
  .editorTop .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
  .editorTop .left, .editorTop .right{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .pill{
    padding:6px 10px; border-radius:999px;
    font-size:12px; border:1px solid var(--border);
    background:var(--card); color:var(--muted); white-space:nowrap;
  }

  .map-info{
    padding:12px 14px; border-top:1px solid var(--border);
    display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
  }
  .map-info .msg{ font-size:13px; color:var(--muted); line-height:1.4; }

  #reader{ display:none; padding:0 14px 14px 14px; }

  /* ===== Orthogonal split panel (inside right card) ===== */
  .splitWrap{ padding:14px; border-top:1px solid var(--border); display:none; }
  .splitWrap.on{ display:block; }
  .splitGrid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }
  @media (max-width: 980px){
    .splitGrid{ grid-template-columns:1fr; }
  }
  .miniCard{
    border:1px solid var(--border);
    border-radius:12px;
    background:var(--card);
    overflow:hidden;
  }
  .miniHead{
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    font-size:12px; color:var(--muted);
  }
  .miniHead b{ color:var(--text); }
  #orthoMap{
    width:100%; height:360px; display:block;
    background:var(--card);
    touch-action:none;
  }

  /* ===== Orthogonal styles ===== */
  .ortho-zone{ fill:rgba(37,99,235,.08); stroke:rgba(37,99,235,.55); stroke-width:0.35; }
  body.dark .ortho-zone{ fill:rgba(37,99,235,.06); stroke:rgba(147,197,253,.55); }
  .ortho-zone.selected{ fill:rgba(251,191,36,.12); stroke:#f97316; stroke-width:0.55; }
  .ortho-rack{ fill:rgba(100,116,139,.12); stroke:rgba(100,116,139,.65); stroke-width:0.2; }
  body.dark .ortho-rack{ fill:rgba(148,163,184,.10); stroke:rgba(148,163,184,.50); }
  .vtx{ fill:#2563eb; }
  .vtx-hit{ fill:rgba(37,99,235,.06); stroke:rgba(37,99,235,.35); stroke-width:0.2; cursor:pointer; }
  .edge-hit{ fill:transparent; stroke:transparent; stroke-width:3; cursor:crosshair; }

  .dims line{ stroke: rgba(245,158,11,.65); stroke-width:0.18; stroke-dasharray: 0.6 0.6; }
  .dims text{ fill:#f59e0b; font-size:1.8px; font-family: monospace; font-weight:900; }
  body.dark .dims text{ fill:#fbbf24; }

  .guides line{ stroke: rgba(37,99,235,.55); stroke-width:0.18; stroke-dasharray: 0.8 0.6; }
  body.dark .guides line{ stroke: rgba(147,197,253,.55); }

  /* ===== Bridges / corridors ===== */
  .bridgeLine{
    stroke: rgba(168,85,247,.85);
    stroke-width: 4;
    stroke-linecap: round;
    stroke-dasharray: 10 7;
    opacity: .85;
  }
  body.dark .bridgeLine{ stroke: rgba(216,180,254,.85); }
  .corridorPoly{
    fill: rgba(168,85,247,.10);
    stroke: rgba(168,85,247,.55);
    stroke-width: 2;
  }
  body.dark .corridorPoly{
    fill: rgba(216,180,254,.08);
    stroke: rgba(216,180,254,.55);
  }

  /* ===== Modal Zone Editor ===== */
  .zmodal{ position:fixed; inset:0; display:none; z-index:9999; }
  .zmodal[aria-hidden="false"]{ display:block; }
  .zmodal__backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.55); backdrop-filter: blur(2px); }
  .zmodal__panel{
    position:relative;
    width:min(1100px, calc(100vw - 24px));
    height:min(760px, calc(100vh - 24px));
    margin:12px auto;
    background:var(--card);
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 18px 50px rgba(0,0,0,.35);
    display:flex;
    flex-direction:column;
    overflow:hidden;
  }
  .zmodal__head{
    padding:14px 16px;
    border-bottom:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .zmodal__title{ font-weight:900; font-size:16px; }
  .zmodal__sub{ font-size:12px; color:var(--muted); margin-top:4px; }
  .zmodal__toolbar{
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    display:flex;
    flex-wrap:wrap;
    align-items:center;
    gap:8px;
  }
  .zpill{
    padding:8px 10px;
    border:1px solid var(--border);
    border-radius:12px;
    background:var(--card);
    color:var(--muted);
    font-size:12px;
    display:flex; align-items:center; gap:8px;
  }
  .zselect{
    border:1px solid var(--border);
    border-radius:10px;
    padding:6px 8px;
    background:var(--card);
    color:var(--text);
    font-weight:800;
  }
  .zbtn{
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    border-radius:12px;
    padding:10px 12px;
    cursor:pointer;
    font-weight:900;
    font-size:13px;
  }
  .zbtn--ghost{ box-shadow:0 8px 18px rgba(0,0,0,.06); }
  .zbtn--primary{ border-color: rgba(37,99,235,.35); background: rgba(37,99,235,.12); }
  .zbtn--danger{ border-color: rgba(220,38,38,.35); background: rgba(220,38,38,.10); }
  .zspacer{ flex:1; }

  .zmodal__body{
    flex:1;
    display:grid;
    grid-template-columns: 1.2fr .8fr;
    gap:12px;
    padding:12px;
  }
  @media (max-width: 980px){
    .zmodal__body{ grid-template-columns:1fr; }
  }
  .zcanvas{
    border:1px solid var(--border);
    border-radius:14px;
    overflow:hidden;
    background:var(--card);
  }
  #zoneMap{
    width:100%;
    height:100%;
    min-height:520px;
    display:block;
    touch-action:none;
  }
  .zhelp{
    border:1px solid var(--border);
    border-radius:14px;
    background:var(--card);
    padding:12px;
    color:var(--muted);
    font-size:13px;
    line-height:1.45;
  }
  .zhelp ul{ margin:8px 0 0 18px; }
  .zmini{ margin-top:10px; padding:10px 12px; border:1px dashed var(--border); border-radius:12px; }

  .zoneHit{
    fill: transparent;
    stroke: transparent;
    stroke-width: 14;
    cursor: pointer;
  }

  /* hide editor-only elements in viewer mode */
  body.viewer .editorTop,
  body.viewer .splitWrap,
  body.viewer #editorPanel { display:none !important; }
  body.editor #editorPanel { display:block; }
</style>
</head>

<body class="viewer">

<div class="topbar">
  <div class="brand">
    <div class="logoMark"><div class="logoBase"></div></div>
    <div class="brandText">
      <div class="title">TIENDAS PG</div>
      <div class="subtitle">Localizador de inventario (PRO)</div>
      <div class="tag" id="modeTag">üëÅÔ∏è VISUALIZADOR</div>
    </div>
  </div>

  <div class="topActions">
    <button class="toggle primary" id="btnModeViewer">üëÅÔ∏è Visualizador</button>
    <button class="toggle" id="btnModeEditor">üõ†Ô∏è Editor</button>
    <button class="toggle" id="btnDark">üåô Modo oscuro</button>

    <div class="status">
      <span class="dot" id="statusDot"></span>
      <span id="statusText">Cargando hoja‚Ä¶</span>
    </div>
  </div>
</div>

<div class="layout">

  <!-- IZQUIERDA -->
  <div class="card">
    <div class="card-header">
      <div>
        <h2>B√∫squeda</h2>
        <div class="meta" id="metaCount">0 productos</div>
      </div>
      <div class="meta" id="metaResults">0 resultados</div>
    </div>

    <div class="controls">
      <div class="search">
        <input id="buscar" type="text" placeholder="Ej: bvd emperador blanco s  |  z1-e1-n6-p2  |  a1-e2-n6-s1" autocomplete="off" />
      </div>

      <div class="chiprow">
        <div class="chip active" id="chipReducido" role="button" tabindex="0">
          Reducido (por nombre) <span class="badge" id="badgeReducido">0</span>
        </div>
        <div class="chip" id="chipDetallado" role="button" tabindex="0">
          Detallado (todo) <span class="badge" id="badgeDetallado">0</span>
        </div>
      </div>

      <div class="btnrow">
        <button class="btn primary" id="btnScan" type="button">üì∑ Escanear</button>
        <button class="btn danger" id="btnCerrar" type="button" style="display:none;">‚ùå Cerrar</button>
        <button class="btn dark" id="btnClear" type="button">üßπ Limpiar</button>
      </div>

      <div class="hint">
        <b>Reducido:</b> 1 fila por nombre. <b>Detallado:</b> todas las coincidencias.
      </div>

      <div class="result-card" id="resultCard">
        <div class="result-title">
          <strong>Resultado activo</strong>
          <span class="pill" id="pillZona">‚Äî</span>
        </div>

        <div class="bigloc" id="bigLoc">‚Äî</div>
        <div class="sub" id="subLoc">‚Äî</div>

        <div class="kv">
          <div class="kv-row">
            <b>üìç Ubicaci√≥n</b>
            <span id="kvUbicacion">‚Äî</span>
          </div>
          <div class="kv-row">
            <b>üß± Estante</b>
            <span id="kvEstante">‚Äî</span>
          </div>
          <div class="kv-row">
            <b>üìö Nivel</b>
            <span id="kvNivel">‚Äî</span>
          </div>
          <div class="kv-row">
            <b>üß© Slot</b>
            <span id="kvSlot">‚Äî</span>
          </div>
          <div class="kv-row">
            <b>üì¶ Almac√©n</b>
            <span id="kvAlmacen">‚Äî</span>
          </div>
        </div>

        <div class="picker">
          <button id="btnPrev" type="button">‚óÄ Anterior</button>
          <div class="counter" id="pickerCounter">0 / 0</div>
          <button id="btnNext" type="button">Siguiente ‚ñ∂</button>
        </div>
      </div>
    </div>

    <div id="reader"></div>

    <div class="table-wrap">
      <div class="table-scroll">
        <table>
          <thead>
            <tr>
              <th style="width:140px;">Barras</th>
              <th>Nombre</th>
              <th style="width:160px;">Variante</th>
              <th style="width:180px;">Ubicaci√≥n</th>
              <th style="width:140px;">Almac√©n</th>
            </tr>
          </thead>
          <tbody id="tabla"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- DERECHA -->
  <div class="card sticky">

    <!-- EDITOR TOP (NO SCROLL) -->
    <div class="editorTop" id="editorTop">
      <div class="row">
        <div class="left">
          <span class="pill" id="editPill">EDIT: OFF</span>
          <button class="toggle" id="btnEditMode" type="button">üß≤ Activar edici√≥n</button>

          <span class="pill" id="toolPill">Herr: Selecci√≥n</span>
          <button class="toggle" id="btnToolSelect" type="button">üñ±Ô∏è Selecci√≥n</button>
          <button class="toggle" id="btnToolZone" type="button">üß© Zonas</button>
          <button class="toggle" id="btnToolRack" type="button">üß± Estantes</button>
          <button class="toggle" id="btnToolBridge" type="button">üåâ Puente</button>

          <button class="toggle" id="btnEditZoneModal" type="button">ü™ü Editar zona</button>
        </div>

        <div class="right">
          <span class="pill" id="selLabel">Sel: ‚Äî</span>

          <span class="pill">Snap</span>
          <select id="snapSelect" style="padding:8px 10px; border-radius:12px; border:1px solid var(--border); background:var(--card); color:var(--text); font-weight:900;">
            <option value="0">OFF</option>
            <option value="0.05">0.05 m</option>
            <option value="0.10" selected>0.10 m</option>
            <option value="0.25">0.25 m</option>
            <option value="0.50">0.50 m</option>
            <option value="1.00">1.00 m</option>
          </select>

          <button class="toggle" id="btnShowOrtho" type="button">üó∫Ô∏è Orto: OFF</button>
          <button class="toggle" id="btnSaveLayout" type="button">üíæ Guardar</button>
          <button class="toggle" id="btnUndo" type="button">‚Ü© Undo</button>
          <button class="toggle" id="btnRedo" type="button">‚Ü™ Redo</button>
          <button class="toggle" id="btnReset" type="button">üß® Reset</button>
        </div>
      </div>
      <div class="hint" style="margin-top:10px;">
        PRO: En edici√≥n, las zonas/estantes se mueven con drag. Zonas: v√©rtices grandes + agregar v√©rtices. Puente: click 2 zonas ‚Üí crea pasillo autom√°tico.
      </div>
    </div>

    <div class="card-header">
      <div>
        <h2>Plano general</h2>
        <div class="meta">Isom√©trico ‚Ä¢ Hover filtra por estante (solo visualizador)</div>
      </div>
      <div class="meta" id="mapBadge">‚Äî</div>
    </div>

    <div id="isoWrap">
      <svg id="isoMap" viewBox="-600 -120 1200 760" preserveAspectRatio="xMidYMid meet"></svg>
    </div>

    <!-- SPLIT VIEW (ORTHO + ISO) -->
    <div class="splitWrap" id="splitWrap">
      <div class="splitGrid">
        <div class="miniCard">
          <div class="miniHead">
            <span><b>Ortogonal</b> (edici√≥n precisa)</span>
            <span class="pill" id="orthoBadge">‚Äî</span>
          </div>
          <svg id="orthoMap" viewBox="0 0 100 80" preserveAspectRatio="xMidYMid meet"></svg>
          <div style="padding:10px 12px; border-top:1px solid var(--border); display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
            <button class="toggle" id="btnOrthoDims">üìè Cotas: OFF</button>
            <button class="toggle" id="btnOrthoRacks">üß± Estantes: ON</button>
            <button class="toggle" id="btnOrthoAddVertex">‚ûï V√©rtice</button>
            <button class="toggle" id="btnOrthoDelVertex">‚ûñ V√©rtice</button>
          </div>
          <div style="padding:10px 12px; color:var(--muted); font-size:12px; border-top:1px dashed var(--border);">
            Tip: para mover v√©rtice ‚Üí click + arrastrar (hitbox grande). Agregar v√©rtice ‚Üí activa ‚Äú‚ûï V√©rtice‚Äù y haz click en borde.
          </div>
        </div>

        <div class="miniCard">
          <div class="miniHead">
            <span><b>Isom√©trico</b> (referencia)</span>
            <span class="pill">Se actualiza en vivo</span>
          </div>
          <div style="padding:12px; color:var(--muted); font-size:12px;">
            Usa el ortogonal para precisi√≥n. El isom√©trico refleja cambios autom√°ticamente.
          </div>
        </div>
      </div>
    </div>

    <!-- VISTA ESTANTE ISO -->
    <div style="padding:14px; border-top:1px solid var(--border);">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
        <div style="font-weight:900;">Vista estante (isom√©trico)</div>
        <div class="pill" id="shelfLabel">‚Äî</div>
      </div>

      <div id="shelfPreview" style="min-height:280px;">
        <div style="color:var(--muted); font-size:13px;">
          Selecciona un producto para ver el estante y la celda resaltada.
        </div>
      </div>
    </div>

    <div class="map-info">
      <div class="msg" id="info">Escribe para buscar o pasa el mouse por los racks.</div>
      <div class="pill" id="resultCountPill">0</div>
    </div>
  </div>

</div>

<!-- ===== MODAL: Editor por Zona ===== -->
<div id="zoneModal" class="zmodal" aria-hidden="true">
  <div class="zmodal__backdrop" id="zoneModalBackdrop"></div>

  <div class="zmodal__panel" role="dialog" aria-modal="true" aria-labelledby="zoneModalTitle">
    <div class="zmodal__head">
      <div>
        <div class="zmodal__title" id="zoneModalTitle">Editor de Zona</div>
        <div class="zmodal__sub" id="zoneModalSub">‚Äî</div>
      </div>
      <div class="zmodal__headActions">
        <button class="zbtn zbtn--ghost" id="zoneModalCloseBtn" type="button">‚úñ Cerrar</button>
      </div>
    </div>

    <div class="zmodal__toolbar">
      <div class="zpill">
        Herramienta:
        <select id="zoneTool" class="zselect">
          <option value="vtx-move" selected>Mover v√©rtices</option>
          <option value="add-vertex">Agregar v√©rtice (clic en borde)</option>
          <option value="del-vertex">Eliminar v√©rtice (clic en v√©rtice)</option>
          <option value="move-zone">Mover zona completa</option>
        </select>
      </div>

      <div class="zpill">
        Snap:
        <select id="zoneSnap" class="zselect">
          <option value="0">OFF</option>
          <option value="0.05">0.05 m</option>
          <option value="0.10" selected>0.10 m</option>
          <option value="0.25">0.25 m</option>
          <option value="0.50">0.50 m</option>
        </select>
      </div>

      <div class="zpill">
        Alineaci√≥n:
        <select id="zoneAlign" class="zselect">
          <option value="0">OFF</option>
          <option value="0.20" selected>0.20 m</option>
          <option value="0.10">0.10 m</option>
          <option value="0.05">0.05 m</option>
        </select>
      </div>

      <button class="zbtn zbtn--ghost" id="zoneToggleDims" type="button">üìè Cotas: OFF</button>
      <button class="zbtn zbtn--ghost" id="zoneToggleRacks" type="button">üß± Estantes: ON</button>

      <div class="zspacer"></div>

      <button class="zbtn zbtn--ghost" id="zoneUndo" type="button">‚Ü© Undo</button>
      <button class="zbtn zbtn--ghost" id="zoneRedo" type="button">‚Ü™ Redo</button>

      <button class="zbtn zbtn--primary" id="zoneApply" type="button">‚úÖ Aplicar</button>
      <button class="zbtn zbtn--danger" id="zoneCancel" type="button">‚õî Cancelar</button>
    </div>

    <div class="zmodal__body">
      <div class="zcanvas">
        <svg id="zoneMap" viewBox="0 0 100 70" preserveAspectRatio="xMidYMid meet"></svg>
      </div>

      <div class="zhelp">
        <div><b>Tips:</b></div>
        <ul>
          <li><b>Mover v√©rtices:</b> click + arrastrar (hitbox grande).</li>
          <li><b>Agregar v√©rtice:</b> clic en el borde (tolerante).</li>
          <li><b>Eliminar v√©rtice:</b> clic en v√©rtice (m√≠n. 3).</li>
          <li><b>Mover zona:</b> arrastra dentro del pol√≠gono.</li>
        </ul>
        <div class="zmini" id="zoneMiniInfo">‚Äî</div>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/html5-qrcode"></script>

<script>
/* =========================
   CONFIG SHEET
========================= */
const sheetID   = "1IU4wMdVImmEbl93kgcCCQAGPiTc28uQdNNaq0bgTF2o";
const sheetName = "Mujer";

/* =========================
   UI refs
========================= */
const tabla = document.getElementById("tabla");
const buscador = document.getElementById("buscar");
const info = document.getElementById("info");
const metaCount = document.getElementById("metaCount");
const metaResults = document.getElementById("metaResults");
const mapBadge = document.getElementById("mapBadge");
const resultCountPill = document.getElementById("resultCountPill");

const statusDot = document.getElementById("statusDot");
const statusText = document.getElementById("statusText");

const resultCard = document.getElementById("resultCard");
const pillZona = document.getElementById("pillZona");
const bigLoc = document.getElementById("bigLoc");
const subLoc = document.getElementById("subLoc");

const kvUbicacion = document.getElementById("kvUbicacion");
const kvEstante = document.getElementById("kvEstante");
const kvNivel = document.getElementById("kvNivel");
const kvSlot = document.getElementById("kvSlot");
const kvAlmacen = document.getElementById("kvAlmacen");

const btnClear = document.getElementById("btnClear");
const btnPrev = document.getElementById("btnPrev");
const btnNext = document.getElementById("btnNext");
const pickerCounter = document.getElementById("pickerCounter");

const chipReducido = document.getElementById("chipReducido");
const chipDetallado = document.getElementById("chipDetallado");
const badgeReducido = document.getElementById("badgeReducido");
const badgeDetallado = document.getElementById("badgeDetallado");

const shelfPreview = document.getElementById("shelfPreview");
const shelfLabel = document.getElementById("shelfLabel");

const btnDark = document.getElementById("btnDark");
const isoMap = document.getElementById("isoMap");

const btnModeViewer = document.getElementById("btnModeViewer");
const btnModeEditor = document.getElementById("btnModeEditor");
const modeTag = document.getElementById("modeTag");

const editorTop = document.getElementById("editorTop");
const editPill  = document.getElementById("editPill");
const btnEditMode   = document.getElementById("btnEditMode");
const selLabel  = document.getElementById("selLabel");
const toolPill  = document.getElementById("toolPill");

const btnToolSelect = document.getElementById("btnToolSelect");
const btnToolZone = document.getElementById("btnToolZone");
const btnToolRack = document.getElementById("btnToolRack");
const btnToolBridge = document.getElementById("btnToolBridge");
const btnEditZoneModal = document.getElementById("btnEditZoneModal");

const snapSelect = document.getElementById("snapSelect");
const btnShowOrtho = document.getElementById("btnShowOrtho");
const splitWrap = document.getElementById("splitWrap");
const orthoMap = document.getElementById("orthoMap");
const orthoBadge = document.getElementById("orthoBadge");

const btnOrthoDims = document.getElementById("btnOrthoDims");
const btnOrthoRacks = document.getElementById("btnOrthoRacks");
const btnOrthoAddVertex = document.getElementById("btnOrthoAddVertex");
const btnOrthoDelVertex = document.getElementById("btnOrthoDelVertex");

const btnSaveLayout = document.getElementById("btnSaveLayout");
const btnUndo = document.getElementById("btnUndo");
const btnRedo = document.getElementById("btnRedo");
const btnReset = document.getElementById("btnReset");

/* Modal zone editor refs */
const zoneModal = document.getElementById("zoneModal");
const zoneModalBackdrop = document.getElementById("zoneModalBackdrop");
const zoneModalCloseBtn = document.getElementById("zoneModalCloseBtn");
const zoneModalSub = document.getElementById("zoneModalSub");
const zoneMap = document.getElementById("zoneMap");
const zoneTool = document.getElementById("zoneTool");
const zoneSnap = document.getElementById("zoneSnap");
const zoneAlign = document.getElementById("zoneAlign");
const zoneToggleDims = document.getElementById("zoneToggleDims");
const zoneToggleRacks = document.getElementById("zoneToggleRacks");
const zoneUndoBtn = document.getElementById("zoneUndo");
const zoneRedoBtn = document.getElementById("zoneRedo");
const zoneApply = document.getElementById("zoneApply");
const zoneCancel = document.getElementById("zoneCancel");
const zoneMiniInfo = document.getElementById("zoneMiniInfo");

/* =========================
   STATE: products/search
========================= */
let productos = [];
let resultadosDetallado = [];
let resultadosReducido = [];
let resultadosActuales = [];
let indiceActual = 0;
let modo = "reducido";
let isLoaded = false;

/* =========================
   STATE: app modes
========================= */
let APP_MODE = "viewer"; // viewer/editor
let EDIT_MODE = false;

function setAppMode(m){
  APP_MODE = m;
  document.body.classList.toggle("viewer", APP_MODE === "viewer");
  document.body.classList.toggle("editor", APP_MODE === "editor");
  modeTag.textContent = APP_MODE === "editor" ? "üõ†Ô∏è EDITOR" : "üëÅÔ∏è VISUALIZADOR";
  btnModeViewer.classList.toggle("primary", APP_MODE === "viewer");
  btnModeEditor.classList.toggle("primary", APP_MODE === "editor");
  editorTop.classList.toggle("on", APP_MODE === "editor");
  if (APP_MODE === "viewer"){
    EDIT_MODE = false;
    setEditModeUI();
    splitWrap.classList.remove("on");
    btnShowOrtho.textContent = "üó∫Ô∏è Orto: OFF";
  }
  refreshAllRenders(false);
}
btnModeViewer.addEventListener("click", ()=> setAppMode("viewer"));
btnModeEditor.addEventListener("click", ()=> setAppMode("editor"));

/* =========================
   Feedback
========================= */
let audioCtx = null;
function beep(freq = 880, ms = 90, vol = 0.06){
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "sine"; o.frequency.value = freq; g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); setTimeout(() => o.stop(), ms);
  }catch(e){}
}
function vibrar(pattern = [60, 40, 60]){
  try{ if (navigator.vibrate) navigator.vibrate(pattern); }catch(e){}
}
function feedbackOK(){
  beep(880, 80, 0.06);
  setTimeout(() => beep(1320, 70, 0.05), 90);
  vibrar([50, 35, 50]);
}

/* =========================
   Helpers
========================= */
function setStatus(type, text){
  statusDot.className = "dot" + (type === "ok" ? " ok" : type === "bad" ? " bad" : "");
  statusText.textContent = text;
}
function escapeHtml(str){
  return String(str || "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function norm(s){
  return String(s || "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9\s-]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}
function tokens(s){
  const stop = new Set(["talla","color","de","para","con","sin","un","una","y","el","la","los","las"]);
  return norm(s).split(" ").filter(w => w && !stop.has(w));
}
function matchAll(textoNorm, qTokens){
  for (const t of qTokens) if (!textoNorm.includes(t)) return false;
  return true;
}

/* =========================
   Parse loc: Z1/Z2/Z3/A1
========================= */
function parseLoc(raw){
  const s = String(raw || "").trim().toUpperCase();
  const m = s.match(/^(Z[123]|A1)-(E\d+)-(N\d+)(?:-(P\d+|S\d+))?$/);
  if (!m) return { zonaId:"", estanteId:"", nivelId:"", levelNum:0, slotNum:0, pretty:s };
  const zonaId = m[1];
  const estanteId = `${zonaId}-${m[2]}`;
  const levelNum = parseInt(m[3].replace("N",""), 10) || 0;
  const slotRaw = m[4] || "";
  const slotNum = slotRaw ? (parseInt(slotRaw.replace(/[PS]/,""),10) || 0) : 0;
  const nivelId = `${estanteId}-${m[3]}`;
  const pretty = slotRaw ? `${zonaId}-${m[2]}-${m[3]}-${slotRaw}` : `${zonaId}-${m[2]}-${m[3]}`;
  return { zonaId, estanteId, nivelId, levelNum, slotNum, pretty };
}

/* =========================
   Vista estante (ISOM√âTRICA)
========================= */
const ISO_ANGLE = 30 * (Math.PI / 180);
const COS_30 = Math.cos(ISO_ANGLE);
const SIN_30 = Math.sin(ISO_ANGLE);
const toScreen = (x,y,z)=>({ x:(x-y)*COS_30, y:(x+y)*SIN_30 - z });

function svgEl(tag, attrs = {}, children = []){
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for (const [k,v] of Object.entries(attrs)){
    if (v === null || v === undefined) continue;
    el.setAttribute(k, String(v));
  }
  for (const c of children) el.appendChild(c);
  return el;
}
function isoFace(coords, attrs){
  const d = `M ${coords[0].x} ${coords[0].y} L ${coords[1].x} ${coords[1].y} L ${coords[2].x} ${coords[2].y} L ${coords[3].x} ${coords[3].y} Z`;
  return svgEl("path", { d, ...attrs });
}
function isoLine(from, to, attrs){
  return svgEl("line", { x1:from.x, y1:from.y, x2:to.x, y2:to.y, ...attrs });
}
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

/* Vista estante */
const SLOTS_PER_LEVEL = 3;
const DEFAULT_SLOT = 2;

function renderShelfIso(estanteId, levelNum, slotNum){
  const isAlmacen = estanteId.startsWith("A1-");
  const levels = isAlmacen ? 8 : 6;
  const slots = SLOTS_PER_LEVEL;

  const rackW = 160;
  const rackD = 85;
  const rackH = 220;
  const shelfSpacing = rackH / levels;

  const viewBox = "-220 -290 440 420";
  const svg = svgEl("svg", { class:"shelfIsoSvg", viewBox, preserveAspectRatio:"xMidYMid meet" });

  const isDark = document.body.classList.contains("dark");
  const floorFill = isDark ? "#0b1220" : "#f8fafc";
  const floorStroke = isDark ? "#1f2937" : "#cbd5e1";

  svg.appendChild(isoFace(
    [toScreen(-20,-20,0), toScreen(rackW+20,-20,0), toScreen(rackW+20,rackD+20,0), toScreen(-20,rackD+20,0)],
    { fill: floorFill, stroke: floorStroke, "stroke-width":"1" }
  ));

  const postStyle = { stroke: isDark ? "#94a3b8" : "#64748b", "stroke-width":"3", "stroke-linecap":"round" };
  svg.appendChild(isoLine(toScreen(0,0,0), toScreen(0,0,rackH), postStyle));
  svg.appendChild(isoLine(toScreen(rackW,0,0), toScreen(rackW,0,rackH), postStyle));

  const thickness = 3;
  const slotW = rackW / slots;
  const fillHL = "#f97316";
  const strokeHL = "#ea580c";

  const safeLevel = clamp(levelNum || 1, 1, levels);
  const safeSlot  = clamp(slotNum || DEFAULT_SLOT, 1, slots);

  for (let i=0;i<levels;i++){
    const z = i*shelfSpacing + 10;
    const lvl = i + 1;
    const isTargetLevel = lvl === safeLevel;

    const top = [toScreen(0,0,z), toScreen(rackW,0,z), toScreen(rackW,rackD,z), toScreen(0,rackD,z)];
    const front = [toScreen(0,rackD,z), toScreen(rackW,rackD,z), toScreen(rackW,rackD,z-thickness), toScreen(0,rackD,z-thickness)];
    const right = [toScreen(rackW,0,z), toScreen(rackW,rackD,z), toScreen(rackW,rackD,z-thickness), toScreen(rackW,0,z-thickness)];

    svg.appendChild(isoFace(top, {
      fill: isDark ? "#243045" : "#e2e8f0",
      stroke: isDark ? "#94a3b8" : "#94a3b8",
      "stroke-width":"0.7",
      opacity: isTargetLevel ? "1" : "0.85"
    }));
    svg.appendChild(isoFace(front, { fill: isDark ? "#1f2a3d" : "#cbd5e1", opacity:"0.85" }));
    svg.appendChild(isoFace(right, { fill: isDark ? "#22314b" : "#b6c2d3", opacity:"0.85" }));

    const labelPos = toScreen(-16, rackD/2, z + shelfSpacing/2);
    const txt = svgEl("text", {
      x: labelPos.x, y: labelPos.y,
      "text-anchor":"middle",
      "font-size": isTargetLevel ? "12" : "10",
      "font-weight": isTargetLevel ? "900" : "700",
      fill: isTargetLevel ? "#f97316" : (isDark ? "#94a3b8" : "#94a3b8"),
      "font-family":"monospace"
    });
    txt.textContent = `N${lvl}`;
    svg.appendChild(txt);

    for (let s=1;s<=slots;s++){
      const x0 = (s-1)*slotW + 3;
      const w = slotW - 6;

      const cellTop = [
        toScreen(x0, 8, z + 1),
        toScreen(x0+w, 8, z + 1),
        toScreen(x0+w, rackD-8, z + 1),
        toScreen(x0, rackD-8, z + 1),
      ];

      const isTargetCell = (lvl === safeLevel) && (s === safeSlot);

      svg.appendChild(isoFace(cellTop, {
        fill: isTargetCell ? fillHL : "transparent",
        stroke: isTargetCell ? strokeHL : (isDark ? "rgba(148,163,184,.30)" : "rgba(148,163,184,.35)"),
        "stroke-width": isTargetCell ? "1.6" : "0.8",
        opacity: isTargetCell ? "0.95" : "1"
      }));
    }
  }

  svg.appendChild(isoLine(toScreen(0,rackD,0), toScreen(0,rackD,rackH), postStyle));
  svg.appendChild(isoLine(toScreen(rackW,rackD,0), toScreen(rackW,rackD,rackH), postStyle));

  const lp = toScreen(rackW/2, rackD/2, rackH + 16);
  svg.appendChild(svgEl("rect", {
    x: lp.x - 58, y: lp.y - 12, width: 116, height: 20, rx: 6,
    fill: isDark ? "#0b1220" : "#ffffff",
    stroke: "#f97316", "stroke-width":"2"
  }));
  const tl = svgEl("text", {
    x: lp.x, y: lp.y + 4,
    "text-anchor":"middle", "font-size":"12", "font-weight":"900", "font-family":"monospace",
    fill: isDark ? "#e5e7eb" : "#1e293b"
  });
  tl.textContent = estanteId;
  svg.appendChild(tl);

  const wrap = document.createElement("div");
  wrap.className = "shelfIsoWrap";
  wrap.innerHTML = `
    <div class="shelfIsoTopbar">
      <span>Slots por nivel: <b>${slots}</b></span>
      <span>Celda pintada: <b>N${safeLevel}</b> / <b>Pos ${safeSlot}</b></span>
    </div>
  `;
  wrap.appendChild(svg);
  return wrap;
}

function mostrarVistaEstante(estanteId, levelNum, slotNum){
  if (!estanteId){
    shelfLabel.textContent = "‚Äî";
    shelfPreview.innerHTML = `<div style="color:var(--muted); font-size:13px;">
      Selecciona un producto para ver el estante y la celda resaltada.
    </div>`;
    return;
  }
  shelfLabel.textContent = estanteId;
  const s = slotNum || DEFAULT_SLOT;
  shelfPreview.innerHTML = "";
  shelfPreview.appendChild(renderShelfIso(estanteId, levelNum || 1, s));
}

/* =========================
   Reducido por nombre
========================= */
function agruparPorNombre(listaDetallada){
  const map = new Map();
  for (const p of listaDetallada){
    const key = (p.nombreNormKey || p.nombreNorm || p.nombre || "").trim();
    if (!key) continue;
    if (!map.has(key)){
      map.set(key, { key, count: 1, representante: p, grupo: [p] });
    } else {
      const g = map.get(key);
      g.count++;
      g.grupo.push(p);
      if ((p._score||0) > (g.representante._score||0)) g.representante = p;
    }
  }
  const reducido = [];
  for (const g of map.values()){
    reducido.push({
      ...g.representante,
      variante: `${g.count} variantes`,
      _grupo: g.grupo,
      _count: g.count,
      _representante: g.representante
    });
  }
  reducido.sort((a,b) => (b._score||0) - (a._score||0));
  return reducido;
}

/* =========================
   Table render
========================= */
function renderTabla(lista, activeIndex = -1){
  let html = "";
  for (let i=0;i<lista.length;i++){
    const p = lista[i];
    const active = i === activeIndex ? " class='active'" : "";
    html += `
      <tr${active} data-i="${i}">
        <td>${escapeHtml(p.barras || "")}</td>
        <td>${escapeHtml(p.nombre || "")}</td>
        <td>${escapeHtml(p.variante || "")}</td>
        <td>${escapeHtml(p.ubic || "")}</td>
        <td>${escapeHtml(p.almacen || "")}</td>
      </tr>`;
  }
  tabla.innerHTML = html;
  enlazarTabla();
}

function enlazarTabla(){
  const rows = tabla.querySelectorAll("tr");
  rows.forEach(tr => {
    tr.addEventListener("mouseenter", () => {
      const i = Number(tr.getAttribute("data-i"));
      const fila = resultadosActuales.length ? resultadosActuales[i] : productos[i];
      const item = (fila && fila._representante) ? fila._representante : fila;
      if (!item) return;
      applyHoverHL(item.mainLoc?.estanteId || "", item.storeLoc?.estanteId || "");
      mapBadge.textContent = item.mainLoc?.zonaId || "‚Äî";
    });

    tr.addEventListener("click", () => {
      const i = Number(tr.getAttribute("data-i"));
      if (!Number.isNaN(i)){
        indiceActual = i;
        aplicarResultadoActivo(true);
      }
    });
  });

  tabla.addEventListener("mouseleave", () => {
    clearHoverHL();
    if (resultadosActuales.length){
      aplicarResultadoActivo(false);
    } else {
      mapBadge.textContent = "‚Äî";
      info.textContent = "Escribe para buscar o pasa el mouse por los racks.";
    }
  }, { once:false });
}

/* =========================
   Picker
========================= */
function setPickerState(){
  const total = resultadosActuales.length;
  pickerCounter.textContent = `${total ? (indiceActual + 1) : 0} / ${total}`;
  btnPrev.disabled = total <= 1;
  btnNext.disabled = total <= 1;
}

/* =========================
   Chips
========================= */
function setModo(nuevo){
  modo = nuevo;
  chipReducido.classList.toggle("active", modo === "reducido");
  chipDetallado.classList.toggle("active", modo === "detallado");

  if (buscador.value.trim()){
    resultadosActuales = (modo === "reducido") ? resultadosReducido : resultadosDetallado;
    indiceActual = 0;
    aplicarResultadoActivo(false);
  } else {
    resultadosActuales = [];
    indiceActual = 0;
    renderTabla(productos);
    resultCard.style.display = "none";
    clearAllHL();
    mostrarVistaEstante("", 0, 0);
    metaResults.textContent = "0 resultados";
    resultCountPill.textContent = "0";
  }
}
chipReducido.addEventListener("click", () => setModo("reducido"));
chipDetallado.addEventListener("click", () => setModo("detallado"));

/* =========================
   Clear
========================= */
function limpiarBusqueda(){
  buscador.value = "";
  resultadosDetallado = [];
  resultadosReducido = [];
  resultadosActuales = [];
  indiceActual = 0;

  metaResults.textContent = "0 resultados";
  resultCountPill.textContent = "0";
  badgeDetallado.textContent = "0";
  badgeReducido.textContent = "0";

  resultCard.style.display = "none";
  clearAllHL();

  info.textContent = "Escribe para buscar o pasa el mouse por los racks.";
  mapBadge.textContent = "‚Äî";
  mostrarVistaEstante("", 0, 0);

  renderTabla(productos);
  buscador.focus();
}
btnClear.addEventListener("click", limpiarBusqueda);

/* =========================
   Search
========================= */
function recalcularResultados(triggerFeedback=false){
  if (!isLoaded) return;

  const qRaw = buscador.value.trim();
  if (!qRaw){
    resultadosDetallado = [];
    resultadosReducido = [];
    resultadosActuales = [];
    indiceActual = 0;
    metaResults.textContent = "0 resultados";
    resultCountPill.textContent = "0";
    badgeDetallado.textContent = "0";
    badgeReducido.textContent = "0";
    resultCard.style.display = "none";
    clearAllHL();
    mostrarVistaEstante("", 0, 0);
    renderTabla(productos);
    return;
  }

  const q = tokens(qRaw);

  resultadosDetallado = productos
    .filter(p => matchAll(p.fulltextNorm, q))
    .map(p => {
      let score = 0;
      for (const t of q) score += p.nvNorm.includes(t) ? 10 : 2;
      return { ...p, _score: score };
    })
    .sort((a,b) => (b._score||0) - (a._score||0));

  resultadosReducido = agruparPorNombre(resultadosDetallado);
  resultadosActuales = (modo === "reducido") ? resultadosReducido : resultadosDetallado;
  indiceActual = 0;
  aplicarResultadoActivo(triggerFeedback);
}
buscador.addEventListener("input", () => recalcularResultados(false));

btnPrev.addEventListener("click", () => {
  if (resultadosActuales.length <= 1) return;
  indiceActual = (indiceActual - 1 + resultadosActuales.length) % resultadosActuales.length;
  aplicarResultadoActivo(true);
});
btnNext.addEventListener("click", () => {
  if (resultadosActuales.length <= 1) return;
  indiceActual = (indiceActual + 1) % resultadosActuales.length;
  aplicarResultadoActivo(true);
});

/* =========================
   Dark mode
========================= */
(function initDark(){
  const saved = localStorage.getItem("darkMode");
  if (saved === "1") document.body.classList.add("dark");
  btnDark.textContent = document.body.classList.contains("dark") ? "‚òÄÔ∏è Modo claro" : "üåô Modo oscuro";
})();
btnDark.addEventListener("click", () => {
  document.body.classList.toggle("dark");
  localStorage.setItem("darkMode", document.body.classList.contains("dark") ? "1" : "0");
  btnDark.textContent = document.body.classList.contains("dark") ? "‚òÄÔ∏è Modo claro" : "üåô Modo oscuro";
  refreshAllRenders(false);
  if (resultadosActuales.length) setTimeout(()=>aplicarResultadoActivo(false), 30);
});

/* =========================
   LAYOUT MODEL (PRO)
========================= */
const LAYOUT_KEY = "pg_layout_pro_v1";
const HISTORY_KEY = "pg_layout_pro_hist_v1";

const DEFAULT_LAYOUT = {
  zones: [
    { id:"Z1", label:"ZONA 1", poly:[{x:2,y:2},{x:28,y:2},{x:28,y:24},{x:2,y:24}] },
    { id:"Z2", label:"ZONA 2", poly:[{x:30,y:2},{x:62,y:2},{x:62,y:24},{x:30,y:24}] },
    { id:"Z3", label:"ZONA 3", poly:[{x:2,y:26},{x:28,y:26},{x:28,y:56},{x:2,y:56}] },
    { id:"A1", label:"ALMAC√âN (A1)", poly:[{x:30,y:26},{x:62,y:26},{x:62,y:56},{x:30,y:56}] },
  ],
  racks: [
    // Z1
    { id:"Z1-E1", zone:"Z1", x:4, y:4, w:4.5, d:11, rot:0 },
    { id:"Z1-E2", zone:"Z1", x:9, y:4, w:4.5, d:11, rot:0 },
    { id:"Z1-E3", zone:"Z1", x:14, y:4, w:4.5, d:11, rot:0 },
    { id:"Z1-E4", zone:"Z1", x:19, y:4, w:4.5, d:11, rot:0 },
    { id:"Z1-E5", zone:"Z1", x:4, y:16, w:4.5, d:11, rot:0 },
    { id:"Z1-E6", zone:"Z1", x:9, y:16, w:4.5, d:11, rot:0 },
    { id:"Z1-E7", zone:"Z1", x:14, y:16, w:4.5, d:11, rot:0 },
    { id:"Z1-E8", zone:"Z1", x:19, y:16, w:4.5, d:11, rot:0 },

    // Z2
    { id:"Z2-E1", zone:"Z2", x:32, y:4, w:4.5, d:11, rot:0 },
    { id:"Z2-E2", zone:"Z2", x:37, y:4, w:4.5, d:11, rot:0 },
    { id:"Z2-E3", zone:"Z2", x:42, y:4, w:4.5, d:11, rot:0 },
    { id:"Z2-E4", zone:"Z2", x:47, y:4, w:4.5, d:11, rot:0 },
    { id:"Z2-E5", zone:"Z2", x:52, y:4, w:4.5, d:11, rot:0 },
    { id:"Z2-E6", zone:"Z2", x:32, y:16, w:4.5, d:11, rot:0 },
    { id:"Z2-E7", zone:"Z2", x:37, y:16, w:4.5, d:11, rot:0 },
    { id:"Z2-E8", zone:"Z2", x:42, y:16, w:4.5, d:11, rot:0 },
    { id:"Z2-E9", zone:"Z2", x:47, y:16, w:4.5, d:11, rot:0 },
    { id:"Z2-E10", zone:"Z2", x:52, y:16, w:4.5, d:11, rot:0 },

    // Z3
    { id:"Z3-E1", zone:"Z3", x:4, y:28, w:4.5, d:11, rot:0 },
    { id:"Z3-E2", zone:"Z3", x:9, y:28, w:4.5, d:11, rot:0 },
    { id:"Z3-E3", zone:"Z3", x:14, y:28, w:4.5, d:11, rot:0 },
    { id:"Z3-E4", zone:"Z3", x:4, y:40, w:4.5, d:11, rot:0 },
    { id:"Z3-E5", zone:"Z3", x:9, y:40, w:4.5, d:11, rot:0 },
    { id:"Z3-E6", zone:"Z3", x:14, y:40, w:4.5, d:11, rot:0 },
    { id:"Z3-E7", zone:"Z3", x:4, y:52, w:4.5, d:11, rot:0 },
    { id:"Z3-E8", zone:"Z3", x:9, y:52, w:4.5, d:11, rot:0 },
    { id:"Z3-E9", zone:"Z3", x:14, y:52, w:4.5, d:11, rot:0 },

    // A1
    { id:"A1-E1", zone:"A1", x:32, y:28, w:4.5, d:11, rot:0 },
    { id:"A1-E2", zone:"A1", x:37, y:28, w:4.5, d:11, rot:0 },
    { id:"A1-E3", zone:"A1", x:42, y:28, w:4.5, d:11, rot:0 },
    { id:"A1-E4", zone:"A1", x:47, y:28, w:4.5, d:11, rot:0 },
    { id:"A1-E5", zone:"A1", x:52, y:28, w:4.5, d:11, rot:0 },
    { id:"A1-E6", zone:"A1", x:32, y:40, w:4.5, d:11, rot:0 },
    { id:"A1-E7", zone:"A1", x:37, y:40, w:4.5, d:11, rot:0 },
    { id:"A1-E8", zone:"A1", x:42, y:40, w:4.5, d:11, rot:0 },
    { id:"A1-E9", zone:"A1", x:47, y:40, w:4.5, d:11, rot:0 },
    { id:"A1-E10", zone:"A1", x:52, y:40, w:4.5, d:11, rot:0 },
    { id:"A1-E11", zone:"A1", x:32, y:52, w:4.5, d:11, rot:0 },
    { id:"A1-E12", zone:"A1", x:37, y:52, w:4.5, d:11, rot:0 },
  ],
  bridges: [] // { id, aZone, bZone, aPt:{x,y}, bPt:{x,y}, width }
};

let layout = loadLayout();
let history = loadHistory();
if (!history || !history.stack || !history.stack.length){
  history = { stack:[JSON.stringify(layout)], idx:0 };
  saveHistory();
}

function loadLayout(){
  try{
    const raw = localStorage.getItem(LAYOUT_KEY);
    if (!raw) return JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
    const obj = JSON.parse(raw);
    if (!obj.zones || !obj.racks) return JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
    if (!obj.bridges) obj.bridges = [];
    return obj;
  }catch(e){
    return JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
  }
}
function saveLayout(){
  localStorage.setItem(LAYOUT_KEY, JSON.stringify(layout));
}
function loadHistory(){
  try{
    const raw = localStorage.getItem(HISTORY_KEY);
    return raw ? JSON.parse(raw) : null;
  }catch(e){ return null; }
}
function saveHistory(){
  localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
}
function pushHistory(label="change"){
  const snap = JSON.stringify(layout);
  history.stack = history.stack.slice(0, history.idx+1);
  history.stack.push(snap);
  history.idx++;
  saveHistory();
}
function undo(){
  if (history.idx <= 0) return;
  history.idx--;
  layout = JSON.parse(history.stack[history.idx]);
  saveLayout();
  refreshAllRenders(true);
}
function redo(){
  if (history.idx >= history.stack.length-1) return;
  history.idx++;
  layout = JSON.parse(history.stack[history.idx]);
  saveLayout();
  refreshAllRenders(true);
}

btnUndo.addEventListener("click", ()=>{ if(APP_MODE==="editor") undo(); });
btnRedo.addEventListener("click", ()=>{ if(APP_MODE==="editor") redo(); });
btnReset.addEventListener("click", ()=>{
  if (APP_MODE!=="editor") return;
  localStorage.removeItem(LAYOUT_KEY);
  localStorage.removeItem(HISTORY_KEY);
  layout = JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
  history = { stack:[JSON.stringify(layout)], idx:0 };
  saveLayout(); saveHistory();
  EDIT_MODE = false;
  setEditModeUI();
  selected = { type:"none", id:"" };
  refreshAllRenders(true);
});
btnSaveLayout.addEventListener("click", ()=>{
  if (APP_MODE!=="editor") return;
  saveLayout();
  feedbackOK();
});

/* =========================
   Editor tools / selection
========================= */
let TOOL = "select"; // select | zone | rack | bridge
let SNAP_M = parseFloat(snapSelect.value);

snapSelect.addEventListener("change", ()=> SNAP_M = parseFloat(snapSelect.value));

function setTool(t){
  TOOL = t;
  toolPill.textContent = `Herr: ${
    t==="select" ? "Selecci√≥n" :
    t==="zone" ? "Zonas" :
    t==="rack" ? "Estantes" : "Puente"
  }`;
  btnToolSelect.classList.toggle("primary", t==="select");
  btnToolZone.classList.toggle("primary", t==="zone");
  btnToolRack.classList.toggle("primary", t==="rack");
  btnToolBridge.classList.toggle("primary", t==="bridge");
  clearTempBridge();
}
btnToolSelect.addEventListener("click", ()=> setTool("select"));
btnToolZone.addEventListener("click", ()=> setTool("zone"));
btnToolRack.addEventListener("click", ()=> setTool("rack"));
btnToolBridge.addEventListener("click", ()=> setTool("bridge"));

function setEditMode(on){
  if (APP_MODE !== "editor") return;
  EDIT_MODE = !!on;
  setEditModeUI();
  refreshAllRenders(false);
}
function setEditModeUI(){
  editPill.textContent = EDIT_MODE ? "EDIT: ON" : "EDIT: OFF";
  btnEditMode.textContent = EDIT_MODE ? "üß≤ Desactivar edici√≥n" : "üß≤ Activar edici√≥n";
  isoMap.classList.toggle("editing", EDIT_MODE);
}
btnEditMode.addEventListener("click", ()=> setEditMode(!EDIT_MODE));

/* =========================
   Ortho view toggles
========================= */
let ORTHO_ON = false;
let ORTHO_SHOW_DIMS = false;
let ORTHO_SHOW_RACKS = true;
let ORTHO_ADD_VTX = false;
let ORTHO_DEL_VTX = false;

btnShowOrtho.addEventListener("click", ()=>{
  if (APP_MODE !== "editor") return;
  ORTHO_ON = !ORTHO_ON;
  splitWrap.classList.toggle("on", ORTHO_ON);
  btnShowOrtho.textContent = ORTHO_ON ? "üó∫Ô∏è Orto: ON" : "üó∫Ô∏è Orto: OFF";
  refreshAllRenders(false);
});
btnOrthoDims.addEventListener("click", ()=>{
  ORTHO_SHOW_DIMS = !ORTHO_SHOW_DIMS;
  btnOrthoDims.textContent = ORTHO_SHOW_DIMS ? "üìè Cotas: ON" : "üìè Cotas: OFF";
  renderOrtho();
});
btnOrthoRacks.addEventListener("click", ()=>{
  ORTHO_SHOW_RACKS = !ORTHO_SHOW_RACKS;
  btnOrthoRacks.textContent = ORTHO_SHOW_RACKS ? "üß± Estantes: ON" : "üß± Estantes: OFF";
  renderOrtho();
});
btnOrthoAddVertex.addEventListener("click", ()=>{
  ORTHO_ADD_VTX = !ORTHO_ADD_VTX;
  ORTHO_DEL_VTX = false;
  btnOrthoAddVertex.classList.toggle("primary", ORTHO_ADD_VTX);
  btnOrthoDelVertex.classList.remove("primary");
  orthoBadge.textContent = ORTHO_ADD_VTX ? "Modo: +V√©rtice" : "‚Äî";
});
btnOrthoDelVertex.addEventListener("click", ()=>{
  ORTHO_DEL_VTX = !ORTHO_DEL_VTX;
  ORTHO_ADD_VTX = false;
  btnOrthoDelVertex.classList.toggle("primary", ORTHO_DEL_VTX);
  btnOrthoAddVertex.classList.remove("primary");
  orthoBadge.textContent = ORTHO_DEL_VTX ? "Modo: -V√©rtice" : "‚Äî";
});

/* =========================
   Geometry helpers
========================= */
function snapM(n){
  if (!SNAP_M || SNAP_M<=0) return n;
  return Math.round(n / SNAP_M) * SNAP_M;
}
function snapPt(p){ return { x:snapM(p.x), y:snapM(p.y) }; }

function polyToPath(poly){
  if (!poly || !poly.length) return "";
  return "M " + poly.map(p=>`${p.x} ${p.y}`).join(" L ") + " Z";
}
function centroid(poly){
  let x=0,y=0;
  for(const p of poly){ x+=p.x; y+=p.y; }
  return { x:x/poly.length, y:y/poly.length };
}
function bbox(poly){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const p of poly){
    minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
    maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
  }
  return { minX,minY,maxX,maxY, w:maxX-minX, h:maxY-minY };
}
function pointInPoly(pt, poly){
  let inside=false;
  for(let i=0,j=poly.length-1; i<poly.length; j=i++){
    const xi=poly[i].x, yi=poly[i].y;
    const xj=poly[j].x, yj=poly[j].y;
    const intersect = ((yi>pt.y)!==(yj>pt.y)) &&
      (pt.x < (xj-xi)*(pt.y-yi)/(yj-yi+1e-9) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
function distPointSeg(p,a,b){
  const abx=b.x-a.x, aby=b.y-a.y;
  const apx=p.x-a.x, apy=p.y-a.y;
  const ab2=abx*abx+aby*aby || 1e-9;
  let t=(apx*abx+apy*aby)/ab2;
  t=Math.max(0,Math.min(1,t));
  const proj={ x:a.x+t*abx, y:a.y+t*aby };
  const d=Math.hypot(p.x-proj.x, p.y-proj.y);
  return { d, proj, t };
}
function nearestEdge(poly, p){
  let best={ d:Infinity, i:-1, proj:null };
  for (let i=0;i<poly.length;i++){
    const a=poly[i], b=poly[(i+1)%poly.length];
    const hit=distPointSeg(p,a,b);
    if (hit.d < best.d){
      best={ d:hit.d, i, proj:hit.proj };
    }
  }
  return best;
}

/* alignment snap (global) */
function alignSnapPoint(p, excludeZoneId=null, threshold=0.20){
  let bestX=null, bestY=null, dxBest=Infinity, dyBest=Infinity;
  for (const z of layout.zones){
    if (excludeZoneId && z.id === excludeZoneId) continue;
    for (const v of z.poly){
      const dx=Math.abs(p.x-v.x);
      const dy=Math.abs(p.y-v.y);
      if (dx < dxBest && dx <= threshold){ dxBest=dx; bestX=v.x; }
      if (dy < dyBest && dy <= threshold){ dyBest=dy; bestY=v.y; }
    }
  }
  const out={...p};
  if(bestX!==null) out.x=bestX;
  if(bestY!==null) out.y=bestY;
  return out;
}

/* SVG point helper for a given svg element */
function getSVGPoint(svg, evt){
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX;
  pt.y = evt.clientY;
  const ctm = svg.getScreenCTM();
  return pt.matrixTransform(ctm.inverse());
}

/* =========================
   ISO RENDER (from layout)
========================= */
let rackNodes = new Map();
let zoneNodes = new Map();
let bridgeNodes = new Map();

function drawIsometric(){
  isoMap.innerHTML = "";
  rackNodes.clear();
  zoneNodes.clear();
  bridgeNodes.clear();

  const isDark = document.body.classList.contains("dark");

  const gZones = svgEl("g", { id:"zones" });

  // floor
  const floor = isoFace(
    [toScreen(0,0,0), toScreen(640,0,0), toScreen(640,560,0), toScreen(0,560,0)],
    { fill: isDark ? "#0b1220" : "#f8fafc", stroke: isDark ? "#1f2937" : "#cbd5e1", "stroke-width":"1" }
  );
  gZones.appendChild(floor);

  // zones -> convert from ortho coords (0..~70) to iso world coords (0..640,0..560)
  // mapping: 1 ortho unit = 10 iso units
  const K = 10;

  for (const z of layout.zones){
    const pts = z.poly.map(p => toScreen(p.x*K, p.y*K, 0));
    // polygon path iso
    const d = "M " + pts.map(p=>`${p.x} ${p.y}`).join(" L ") + " Z";
    const cls = z.id==="Z1" ? "z1" : z.id==="Z2" ? "z2" : z.id==="Z3" ? "z3" : "a1";
    const poly = svgEl("path", { d, id:z.id, class:`iso-zone ${cls}`, "stroke-width":"2" });
    zoneNodes.set(z.id, poly);
    gZones.appendChild(poly);

    // HIT overlay (thick invisible stroke) for easier selection
    const hit = svgEl("path", { d, class:"zoneHit", "data-zone-id": z.id });
    gZones.appendChild(hit);
  }

  isoMap.appendChild(gZones);

  // corridors & bridges
  drawBridgesIso(K);

  // racks
  const zoneColor = { Z1:"#14b8a6", Z2:"#2dd4bf", Z3:"#5eead4", A1:"#93c5fd" };
  const gRacks = svgEl("g", { id:"racks" });

  for (const r of layout.racks){
    const node = drawRackIso(r, zoneColor[r.zone], K);
    node.id = r.id;
    rackNodes.set(r.id, node);

    // viewer hover filter
    node.addEventListener("mouseenter", () => {
      if (APP_MODE!=="viewer") return;
      clearHoverHL();
      node.classList.add("hoverHL");
      mapBadge.textContent = r.zone;
      if (document.activeElement === buscador) return;
      if (isoMap._lastHoverQuery === undefined) isoMap._lastHoverQuery = buscador.value;
      buscador.value = r.id.toLowerCase();
      recalcularResultados(false);
    });
    node.addEventListener("mouseleave", () => {
      if (APP_MODE!=="viewer") return;
      node.classList.remove("hoverHL");
      mapBadge.textContent = "‚Äî";
      if (document.activeElement === buscador) return;
      if (isoMap._lastHoverQuery !== undefined){
        buscador.value = isoMap._lastHoverQuery;
        isoMap._lastHoverQuery = undefined;
        recalcularResultados(false);
      }
    });
    node.addEventListener("click", () => {
      if (APP_MODE!=="viewer") return;
      isoMap._lastHoverQuery = undefined;
      buscador.value = r.id.toLowerCase();
      recalcularResultados(true);
    });

    // editor selection
    node.addEventListener("pointerdown", (ev)=>{
      if (APP_MODE!=="editor" || !EDIT_MODE) return;
      if (TOOL !== "rack" && TOOL !== "select") return;
      ev.preventDefault(); ev.stopPropagation();
      selectItem("rack", r.id);
      startDragIso(ev, "rack", r.id);
    });

    gRacks.appendChild(node);
  }
  isoMap.appendChild(gRacks);

  // zone interactions (hit overlays)
  isoMap.querySelectorAll(".zoneHit").forEach(hit=>{
    hit.addEventListener("pointerdown",(ev)=>{
      if (APP_MODE!=="editor" || !EDIT_MODE) return;
      if (TOOL !== "zone" && TOOL !== "select" && TOOL !== "bridge") return;
      ev.preventDefault(); ev.stopPropagation();
      const zid = hit.getAttribute("data-zone-id");
      if (!zid) return;

      if (TOOL === "bridge"){
        handleBridgePick(zid);
        return;
      }

      selectItem("zone", zid);
      startDragIso(ev, "zone", zid);
    });
  });

  // background click clears selection (editor only)
  isoMap.addEventListener("pointerdown",(ev)=>{
    if (APP_MODE!=="editor" || !EDIT_MODE) return;
    if (ev.target === isoMap){
      selectItem("none", "");
      clearGuidesIso();
      clearTempBridge();
    }
  });

  // highlight selection
  applySelectionHighlight();
}

function drawRackIso(r, zoneColor, K){
  const x = r.x*K, y=r.y*K, w=r.w*K, d=r.d*K;
  const h = (r.zone==="A1") ? 140 : 120;
  const levels = (r.zone==="A1") ? 8 : 6;
  const rot = r.rot || 0;

  const g = svgEl("g", { class:"rack", "data-rack-id": r.id });

  let W=w, D=d;
  const rr = ((rot%360)+360)%360;
  if (rr===90 || rr===270){ W=d; D=w; }

  const postsBack = [{x:x, y:y},{x:x+W, y:y}];
  for (const p of postsBack){
    g.appendChild(isoLine(toScreen(p.x,p.y,0), toScreen(p.x,p.y,h), { class:"post" }));
  }

  const spacing = h / levels;
  const thickness = 2;

  for (let i=0;i<levels;i++){
    const z = i*spacing + 10;
    const top = [toScreen(x,y,z), toScreen(x+W,y,z), toScreen(x+W,y+D,z), toScreen(x,y+D,z)];
    const front = [toScreen(x,y+D,z), toScreen(x+W,y+D,z), toScreen(x+W,y+D,z-thickness), toScreen(x,y+D,z-thickness)];
    const right = [toScreen(x+W,y,z), toScreen(x+W,y+D,z), toScreen(x+W,y+D,z-thickness), toScreen(x+W,y,z-thickness)];
    g.appendChild(isoFace(top,   { class:"shelfTop" }));
    g.appendChild(isoFace(front, { class:"shelfFront" }));
    g.appendChild(isoFace(right, { class:"shelfRight" }));
  }

  const postsFront = [{x:x+W, y:y+D},{x:x, y:y+D}];
  for (const p of postsFront){
    g.appendChild(isoLine(toScreen(p.x,p.y,0), toScreen(p.x,p.y,h), { class:"post" }));
  }

  const lp = toScreen(x + W/2, y + D/2, h + 18);
  const rect = svgEl("rect", {
    x: lp.x - 18, y: lp.y - 12, width: 36, height: 20, rx: 5,
    fill: "#ffffff", stroke: zoneColor, "stroke-width":"2"
  });
  const txt = svgEl("text", {
    x: lp.x, y: lp.y + 5,
    "text-anchor":"middle", "font-size":"11", "font-weight":"900", "font-family":"monospace",
    fill: "#1e293b"
  });
  txt.textContent = r.id.split("-")[1];
  g.appendChild(rect);
  g.appendChild(txt);

  return g;
}

/* =========================
   Bridges: create corridor automatically
========================= */
function clearTempBridge(){ isoMap._bridgePick = null; }
function handleBridgePick(zoneId){
  if (!isoMap._bridgePick){
    isoMap._bridgePick = zoneId;
    info.textContent = `üåâ Puente: selecciona la segunda zona para conectar con ${zoneId}`;
    return;
  }
  const a = isoMap._bridgePick;
  const b = zoneId;
  isoMap._bridgePick = null;

  if (a === b){
    info.textContent = "üåâ Puente cancelado (misma zona).";
    return;
  }

  // create bridge model
  const id = `BR-${Date.now().toString(36)}`;
  const width = 3; // ortho units (~0.3m if 1u=0.1m). Ajusta si quieres.
  layout.bridges.push({ id, aZone:a, bZone:b, width });
  pushHistory("add bridge");
  saveLayout();
  refreshAllRenders(true);
  feedbackOK();
}

function zoneCenterOrtho(zoneId){
  const z = layout.zones.find(z=>z.id===zoneId);
  if (!z) return {x:0,y:0};
  return centroid(z.poly);
}

function corridorFromCenters(a, b, width){
  // "pasillo" rectangular alrededor de la l√≠nea centro-centro
  const dx = b.x-a.x, dy=b.y-a.y;
  const len = Math.hypot(dx,dy) || 1e-9;
  const nx = -dy/len, ny = dx/len; // normal
  const w = width/2;
  return [
    {x:a.x + nx*w, y:a.y + ny*w},
    {x:b.x + nx*w, y:b.y + ny*w},
    {x:b.x - nx*w, y:b.y - ny*w},
    {x:a.x - nx*w, y:a.y - ny*w},
  ];
}

function drawBridgesIso(K){
  if (!layout.bridges || !layout.bridges.length) return;

  const g = svgEl("g",{ id:"bridges" });
  for (const br of layout.bridges){
    const aC = zoneCenterOrtho(br.aZone);
    const bC = zoneCenterOrtho(br.bZone);

    // corridor polygon in ortho -> iso
    const cor = corridorFromCenters(aC, bC, br.width || 3);
    const pts = cor.map(p => toScreen(p.x*K, p.y*K, 0));
    const dPoly = "M " + pts.map(p=>`${p.x} ${p.y}`).join(" L ") + " Z";
    g.appendChild(svgEl("path",{ d:dPoly, class:"corridorPoly" }));

    // bridge center line
    const aIso = toScreen(aC.x*K, aC.y*K, 0);
    const bIso = toScreen(bC.x*K, bC.y*K, 0);
    g.appendChild(svgEl("line",{
      x1:aIso.x, y1:aIso.y, x2:bIso.x, y2:bIso.y,
      class:"bridgeLine"
    }));
  }
  isoMap.appendChild(g);
}

/* =========================
   HL helpers
========================= */
function clearMainHL(){
  for (const z of zoneNodes.values()) z.classList.remove("mainHL");
  for (const r of rackNodes.values()) r.classList.remove("mainHL");
}
function clearStoreHL(){
  for (const z of zoneNodes.values()) z.classList.remove("storeHL");
  for (const r of rackNodes.values()) r.classList.remove("storeHL");
}
function clearHoverHL(){
  for (const r of rackNodes.values()) r.classList.remove("hoverHL");
}
function clearAllHL(){ clearMainHL(); clearStoreHL(); clearHoverHL(); }

function applyHoverHL(mainRackId, storeRackId){
  clearHoverHL();
  if (mainRackId && rackNodes.get(mainRackId)) rackNodes.get(mainRackId).classList.add("hoverHL");
  if (storeRackId && rackNodes.get(storeRackId)) rackNodes.get(storeRackId).classList.add("hoverHL");
}

function applyMainStoreHL(mainLoc, storeLoc){
  clearMainHL(); clearStoreHL();

  if (mainLoc?.zonaId && zoneNodes.get(mainLoc.zonaId)) zoneNodes.get(mainLoc.zonaId).classList.add("mainHL");
  if (mainLoc?.estanteId && rackNodes.get(mainLoc.estanteId)) rackNodes.get(mainLoc.estanteId).classList.add("mainHL");

  if (storeLoc?.zonaId && zoneNodes.get(storeLoc.zonaId)) zoneNodes.get(storeLoc.zonaId).classList.add("storeHL");
  if (storeLoc?.estanteId && rackNodes.get(storeLoc.estanteId)) rackNodes.get(storeLoc.estanteId).classList.add("storeHL");

  const hasSelection = !!(mainLoc?.estanteId || storeLoc?.estanteId);
  if (hasSelection){
    for (const node of rackNodes.values()){
      const keep = node.classList.contains("mainHL") || node.classList.contains("storeHL");
      node.classList.toggle("dim", !keep);
    }
  } else {
    for (const node of rackNodes.values()) node.classList.remove("dim");
  }
}

/* =========================
   Active result + highlight
========================= */
function aplicarResultadoActivo(triggerFeedback = false){
  const total = resultadosActuales.length;

  metaResults.textContent = `${total} resultados`;
  resultCountPill.textContent = String(total);

  badgeDetallado.textContent = String(resultadosDetallado.length || 0);
  badgeReducido.textContent = String(resultadosReducido.length || 0);

  if (!total){
    resultCard.style.display = "none";
    clearAllHL();
    info.textContent = "Escribe para buscar o pasa el mouse por los racks.";
    mapBadge.textContent = "‚Äî";
    mostrarVistaEstante("", 0, 0);
    return;
  }

  if (indiceActual < 0) indiceActual = 0;
  if (indiceActual >= total) indiceActual = total - 1;

  const filaActiva = resultadosActuales[indiceActual];
  const activo = (modo === "reducido" && filaActiva._representante)
    ? filaActiva._representante
    : filaActiva;

  renderTabla(resultadosActuales, indiceActual);

  applyMainStoreHL(activo.mainLoc, activo.storeLoc);

  mapBadge.textContent = activo.mainLoc?.zonaId || "‚Äî";
  pillZona.textContent = activo.mainLoc?.zonaId || "‚Äî";

  const mainPretty = activo.mainLoc?.pretty || "‚Äî";
  const storePretty = (activo.storeLoc?.pretty && activo.storeLoc?.zonaId) ? activo.storeLoc.pretty : "";

  info.textContent = storePretty
    ? `üìç Ubicaci√≥n: ${mainPretty}  ‚Ä¢  üì¶ Almac√©n: ${storePretty}`
    : `üìç Ubicaci√≥n: ${mainPretty}`;

  resultCard.style.display = "block";
  bigLoc.textContent = storePretty ? `${mainPretty}  |  ALMAC√âN: ${storePretty}` : mainPretty;

  subLoc.textContent = (modo === "reducido" && filaActiva._count)
    ? `${filaActiva.nombre || "‚Äî"} ‚Ä¢ ${filaActiva._count} variantes`
    : `${activo.nombre || "‚Äî"} ‚Ä¢ ${activo.variante || "‚Äî"} ‚Ä¢ ${activo.barras || "‚Äî"}`;

  kvUbicacion.textContent = mainPretty || "‚Äî";
  kvEstante.textContent = activo.mainLoc?.estanteId || "‚Äî";
  kvNivel.textContent = activo.mainLoc?.nivelId || "‚Äî";
  kvSlot.textContent = (activo.mainLoc?.slotNum ? `P${activo.mainLoc.slotNum}` : "‚Äî");
  kvAlmacen.textContent = storePretty || "‚Äî";

  mostrarVistaEstante(
    activo.mainLoc?.estanteId || "",
    activo.mainLoc?.levelNum || 1,
    activo.mainLoc?.slotNum || DEFAULT_SLOT
  );

  setPickerState();
  if (triggerFeedback) feedbackOK();
}

/* =========================
   SHEET LOADER (FIX robust)
========================= */
setStatus("warn", `Cargando hoja ‚Äú${sheetName}‚Äù...`);

function parseGViz(text){
  // robust extract of setResponse({...})
  const m = text.match(/google\.visualization\.Query\.setResponse\(([\s\S]*?)\);\s*$/);
  if (!m) throw new Error("GViz wrapper not found");
  return JSON.parse(m[1]);
}

async function fetchSheet(){
  const bust = Date.now();
  const url = `https://docs.google.com/spreadsheets/d/${sheetID}/gviz/tq?tqx=out:json&tq=${encodeURIComponent("select *")}&sheet=${encodeURIComponent(sheetName)}&cachebust=${bust}`;
  const res = await fetch(url, { cache:"no-store" });
  if (!res.ok) throw new Error("HTTP " + res.status);
  const text = await res.text();
  return parseGViz(text);
}

fetchSheet()
  .then(json => {
    const rows = json.table.rows || [];

    productos = [];
    for (const r of rows){
      if (!r.c) continue;

      // Mantengo tus columnas (10,12,13,20,21)
      const barras = r.c[10]?.v || "";
      const nombre = r.c[12]?.v || "";
      const variante = r.c[13]?.v || "";

      const ubicRaw = r.c[20]?.v || "";
      const almacenRaw = r.c[21]?.v || "";

      const mainLoc = parseLoc(ubicRaw);
      const storeLoc = parseLoc(almacenRaw);

      const p = { barras, nombre, variante, ubic: mainLoc.pretty || "", almacen: storeLoc.pretty || "", mainLoc, storeLoc };
      if (!barras && !nombre) continue;

      p.nvNorm = norm((p.nombre || "") + " " + (p.variante || ""));
      p.fulltextNorm = norm((p.barras||"") + " " + (p.nombre||"") + " " + (p.variante||"") + " " + (p.ubic||"") + " " + (p.almacen||""));
      p.nombreNorm = norm(p.nombre);
      p.nombreNormKey = p.nombreNorm;

      productos.push(p);
    }

    metaCount.textContent = `${productos.length} productos`;
    renderTabla(productos);

    isLoaded = true;
    setStatus("ok", `Listo ‚Ä¢ ${productos.length} productos cargados`);

    // Optional: auto-create missing racks from sheet racks ids (non destructive)
    hydrateRacksFromSheet();
    pushHistory("load");
    saveLayout();
    saveHistory();

    refreshAllRenders(false);
  })
  .catch((e) => {
    console.error(e);
    setStatus("bad", "Error cargando la hoja. Verifica: (1) Sheet p√∫blico, (2) nombre de hoja exacto, (3) columnas correctas.");
  });

/* If the sheet includes rack IDs not in layout, add them */
function hydrateRacksFromSheet(){
  const ids = new Set(layout.racks.map(r=>r.id));
  for (const p of productos){
    const a = p.mainLoc?.estanteId;
    const b = p.storeLoc?.estanteId;
    if (a && !ids.has(a)){ ids.add(a); layout.racks.push(makeRackDefault(a)); }
    if (b && !ids.has(b)){ ids.add(b); layout.racks.push(makeRackDefault(b)); }
  }
}
function makeRackDefault(rid){
  const zid = rid.split("-")[0];
  const z = layout.zones.find(z=>z.id===zid) || layout.zones[0];
  const bb = bbox(z.poly);
  return { id:rid, zone:zid, x:bb.minX+1, y:bb.minY+1, w:4.5, d:11, rot:0 };
}

/* =========================
   Scanner
========================= */
const btnScan = document.getElementById("btnScan");
const btnCerrar = document.getElementById("btnCerrar");
const readerDiv = document.getElementById("reader");
let html5QrCode = null;

btnScan.addEventListener("click", () => {
  readerDiv.style.display = "block";
  btnCerrar.style.display = "inline-flex";
  if (!html5QrCode) html5QrCode = new Html5Qrcode("reader");

  Html5Qrcode.getCameras().then(cameras => {
    const cameraId = cameras.find(c => c.label.toLowerCase().includes("back"))?.id || cameras[0]?.id;
    if (!cameraId) return;

    html5QrCode.start(
      cameraId,
      { fps: 20, qrbox: { width: 260, height: 200 }, experimentalFeatures: { useBarCodeDetectorIfSupported: true } },
      codigo => {
        html5QrCode.stop().then(() => {
          readerDiv.style.display = "none";
          btnCerrar.style.display = "none";
        });
        feedbackOK();
        buscador.value = codigo;
        recalcularResultados(false);
      }
    );
  });
});

btnCerrar.addEventListener("click", () => {
  if (html5QrCode){
    html5QrCode.stop().then(() => {
      readerDiv.style.display = "none";
      btnCerrar.style.display = "none";
    });
  }
});

/* =========================
   Selection (global)
========================= */
let selected = { type:"none", id:"" };

function selectItem(type, id){
  selected = { type, id };
  selLabel.textContent = `Sel: ${type==="none" ? "‚Äî" : `${type.toUpperCase()} ${id}`}`;
  applySelectionHighlight();
  if (ORTHO_ON) renderOrtho();
}

function applySelectionHighlight(){
  for (const z of zoneNodes.values()) z.classList.remove("selected");
  for (const r of rackNodes.values()) r.classList.remove("selected");

  if (selected.type==="zone" && selected.id){
    const zn = zoneNodes.get(selected.id);
    if (zn) zn.classList.add("selected");
  }
  if (selected.type==="rack" && selected.id){
    const rn = rackNodes.get(selected.id);
    if (rn) rn.classList.add("selected");
  }
}

/* =========================
   Editor Drag on ISO (zones/racks)
========================= */
let isoDragging = false;
let isoDrag = null;
let isoGuideLayer = null;

function ensureGuidesIso(){
  if (isoGuideLayer) return isoGuideLayer;
  isoGuideLayer = svgEl("g",{ class:"guides" });
  isoMap.appendChild(isoGuideLayer);
  return isoGuideLayer;
}
function clearGuidesIso(){ if (isoGuideLayer) isoGuideLayer.innerHTML=""; }

function drawGuidesIsoText(msg){
  const g = ensureGuidesIso();
  g.innerHTML = "";
  const t = svgEl("text",{ x:-560, y:-90, "font-family":"monospace", "font-weight":"900", "font-size":"14", fill:"#2563eb" });
  t.textContent = msg;
  g.appendChild(t);
}
function screenToWorld(dxScreen, dyScreen){
  const x = (dxScreen / COS_30 + dyScreen / SIN_30) / 2;
  const y = (dyScreen / SIN_30 - dxScreen / COS_30) / 2;
  return { x, y };
}
function getSVGPointIso(evt){
  const pt = isoMap.createSVGPoint();
  pt.x = evt.clientX;
  pt.y = evt.clientY;
  const ctm = isoMap.getScreenCTM();
  return pt.matrixTransform(ctm.inverse());
}

function startDragIso(ev, kind, id){
  const p0 = getSVGPointIso(ev);

  isoDragging = true;
  isoDrag = { kind, id, start:{x:p0.x,y:p0.y}, moved:false };

  if (kind==="rack"){
    const r = layout.racks.find(r=>r.id===id);
    if (!r) return;
    isoDrag.r0 = { x:r.x, y:r.y };
  }

  if (kind==="zone"){
    const z = layout.zones.find(z=>z.id===id);
    if (!z) return;
    isoDrag.poly0 = z.poly.map(p=>({x:p.x,y:p.y}));
    // also: move racks of zone together (PRO)
    isoDrag.racks0 = layout.racks.filter(r=>r.zone===id).map(r=>({ id:r.id, x:r.x, y:r.y }));
  }

  isoMap.setPointerCapture(ev.pointerId);
}

isoMap.addEventListener("pointermove",(ev)=>{
  if (!isoDragging || !isoDrag) return;
  const p = getSVGPointIso(ev);
  const dxS = p.x - isoDrag.start.x;
  const dyS = p.y - isoDrag.start.y;

  const dW = screenToWorld(dxS, dyS); // in ISO world units (same as K*ortho)
  const K = 10;
  const dxO = (dW.x)/K;
  const dyO = (dW.y)/K;

  if (Math.hypot(dxO,dyO) > 0.05) isoDrag.moved = true;

  if (isoDrag.kind==="rack"){
    const r = layout.racks.find(r=>r.id===isoDrag.id);
    if (!r) return;
    r.x = snapM(isoDrag.r0.x + dxO);
    r.y = snapM(isoDrag.r0.y + dyO);
    drawGuidesIsoText(`${r.id}  X:${r.x.toFixed(2)}  Y:${r.y.toFixed(2)}`);
    drawIsometric();
    renderOrthoThrottled();
  }

  if (isoDrag.kind==="zone"){
    const z = layout.zones.find(z=>z.id===isoDrag.id);
    if (!z) return;

    const dx = snapM(dxO);
    const dy = snapM(dyO);

    z.poly = isoDrag.poly0.map(p=>({ x:p.x+dx, y:p.y+dy }));

    // move all racks belonging to that zone (PRO)
    for (const r0 of isoDrag.racks0){
      const rr = layout.racks.find(r=>r.id===r0.id);
      if (rr){
        rr.x = snapM(r0.x + dx);
        rr.y = snapM(r0.y + dy);
      }
    }

    drawGuidesIsoText(`${z.id} movida  dX:${dx.toFixed(2)}  dY:${dy.toFixed(2)}`);
    drawIsometric();
    renderOrthoThrottled();
  }
});

isoMap.addEventListener("pointerup",(ev)=>{
  if (!isoDragging || !isoDrag) return;
  isoDragging = false;

  if (isoDrag.moved){
    pushHistory("drag");
    saveLayout();
    feedbackOK();
  }
  isoDrag = null;
  clearGuidesIso();
});
isoMap.addEventListener("pointercancel",()=>{
  isoDragging=false; isoDrag=null; clearGuidesIso();
});

/* =========================
   Orthogonal editor
========================= */
let orthoGuidesLayer = null;
let orthoDimsLayer = null;
let orthoDragging = false;
let orthoDrag = null;

function orthoViewBox(){
  // global bbox of all zones + padding
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for (const z of layout.zones){
    const bb = bbox(z.poly);
    minX=Math.min(minX,bb.minX);
    minY=Math.min(minY,bb.minY);
    maxX=Math.max(maxX,bb.maxX);
    maxY=Math.max(maxY,bb.maxY);
  }
  const pad = 4;
  return { x:minX-pad, y:minY-pad, w:(maxX-minX)+pad*2, h:(maxY-minY)+pad*2 };
}

function drawAlignmentGuides(svg, p){
  if (!orthoGuidesLayer){
    orthoGuidesLayer = svgEl("g",{ class:"guides" });
    svg.appendChild(orthoGuidesLayer);
  }
  orthoGuidesLayer.innerHTML = "";
  orthoGuidesLayer.appendChild(svgEl("line",{ x1:p.x-999, y1:p.y, x2:p.x+999, y2:p.y }));
  orthoGuidesLayer.appendChild(svgEl("line",{ x1:p.x, y1:p.y-999, x2:p.x, y2:p.y+999 }));
}

function drawEdgeDimsForPoly(svg, poly){
  if (!orthoDimsLayer){
    orthoDimsLayer = svgEl("g",{ class:"dims" });
    svg.appendChild(orthoDimsLayer);
  }
  orthoDimsLayer.innerHTML = "";
  for (let i=0;i<poly.length;i++){
    const a=poly[i], b=poly[(i+1)%poly.length];
    const mid={ x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
    const len=Math.hypot(b.x-a.x, b.y-a.y);
    orthoDimsLayer.appendChild(svgEl("line",{ x1:a.x, y1:a.y, x2:b.x, y2:b.y }));
    const t=svgEl("text",{ x:mid.x, y:mid.y, "text-anchor":"middle" });
    t.textContent = `${len.toFixed(2)}u`;
    orthoDimsLayer.appendChild(t);
  }
}

function renderOrtho(){
  if (APP_MODE!=="editor" || !ORTHO_ON) return;
  const vb = orthoViewBox();
  orthoMap.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
  orthoMap.innerHTML = "";
  orthoGuidesLayer = null;
  orthoDimsLayer = null;

  // zones
  for (const z of layout.zones){
    const path = svgEl("path",{ d: polyToPath(z.poly), class:`ortho-zone ${selected.type==="zone" && selected.id===z.id ? "selected":""}` });
    orthoMap.appendChild(path);

    const edgeHit = svgEl("path",{ d: polyToPath(z.poly), class:"edge-hit", "data-zone-id": z.id });
    edgeHit.addEventListener("click",(ev)=>{
      if (!EDIT_MODE) return;
      if (!ORTHO_ADD_VTX) return;
      ev.preventDefault(); ev.stopPropagation();
      const zid=edgeHit.getAttribute("data-zone-id");
      const zone=layout.zones.find(zz=>zz.id===zid);
      if (!zone) return;
      const p = getSVGPoint(orthoMap, ev);
      const hit = nearestEdge(zone.poly, p);
      if (hit.d > 1.15) return;
      let np = snapPt(hit.proj);
      np = alignSnapPoint(np, zone.id, 0.20);
      zone.poly.splice(hit.i+1, 0, np);
      pushHistory("add vertex");
      saveLayout();
      refreshAllRenders(true);
      feedbackOK();
    });
    orthoMap.appendChild(edgeHit);

    // zone label
    const c = centroid(z.poly);
    const t = svgEl("text",{ x:c.x, y:c.y, "text-anchor":"middle", "font-size":"2.8", "font-weight":"900", "font-family":"monospace",
      fill: document.body.classList.contains("dark") ? "rgba(148,163,184,.85)" : "rgba(17,24,39,.55)" });
    t.textContent = z.id;
    orthoMap.appendChild(t);
  }

  // racks
  if (ORTHO_SHOW_RACKS){
    for (const r of layout.racks){
      const rect = svgEl("rect",{ x:r.x, y:r.y, width:r.w, height:r.d, rx:0.4, class:"ortho-rack" });
      rect.addEventListener("pointerdown",(ev)=>{
        if (!EDIT_MODE) return;
        if (TOOL!=="rack" && TOOL!=="select") return;
        ev.preventDefault(); ev.stopPropagation();
        selectItem("rack", r.id);
        startDragOrtho(ev, "rack", r.id);
      });
      orthoMap.appendChild(rect);
    }
  }

  // vertices for selected zone (or all when tool zone)
  const activeZoneId = (selected.type==="zone" ? selected.id : null);
  const zoneForVtx = activeZoneId ? layout.zones.find(z=>z.id===activeZoneId) : null;

  if (zoneForVtx){
    if (ORTHO_SHOW_DIMS) drawEdgeDimsForPoly(orthoMap, zoneForVtx.poly);

    const VTX_HIT_R = 1.8;  // big hit
    const VTX_R = 0.7;

    zoneForVtx.poly.forEach((p, idx)=>{
      const hit = svgEl("circle",{ cx:p.x, cy:p.y, r:VTX_HIT_R, class:"vtx-hit", "data-idx": idx });
      const c = svgEl("circle",{ cx:p.x, cy:p.y, r:VTX_R, class:"vtx", "data-idx": idx });

      const down = (ev)=>{
        if (!EDIT_MODE) return;
        ev.preventDefault(); ev.stopPropagation();

        if (ORTHO_DEL_VTX){
          if (zoneForVtx.poly.length <= 3) return;
          zoneForVtx.poly.splice(idx, 1);
          pushHistory("del vertex");
          saveLayout();
          refreshAllRenders(true);
          feedbackOK();
          return;
        }

        // default move vertex
        startDragOrtho(ev, "vtx", { zoneId: zoneForVtx.id, idx });
      };

      hit.addEventListener("pointerdown", down);
      c.addEventListener("pointerdown", down);

      orthoMap.appendChild(hit);
      orthoMap.appendChild(c);
    });

    // zone drag by clicking inside polygon
    const hitFill = svgEl("path",{ d: polyToPath(zoneForVtx.poly), fill:"transparent", stroke:"transparent", "stroke-width":"0.4" });
    hitFill.addEventListener("pointerdown",(ev)=>{
      if (!EDIT_MODE) return;
      if (TOOL!=="zone" && TOOL!=="select") return;
      ev.preventDefault(); ev.stopPropagation();
      const p = getSVGPoint(orthoMap, ev);
      if (!pointInPoly(p, zoneForVtx.poly)) return;
      startDragOrtho(ev, "zone", zoneForVtx.id);
    });
    orthoMap.appendChild(hitFill);
  } else {
    // no zone selected
    orthoBadge.textContent = "Selecciona una zona";
  }
}

let orthoRAF = null;
function renderOrthoThrottled(){
  if (!ORTHO_ON) return;
  if (orthoRAF) return;
  orthoRAF = requestAnimationFrame(()=>{
    orthoRAF = null;
    renderOrtho();
  });
}

function startDragOrtho(ev, kind, payload){
  const p0 = getSVGPoint(orthoMap, ev);
  orthoDragging = true;
  orthoDrag = { kind, payload, start:p0, moved:false };

  if (kind==="rack"){
    const r = layout.racks.find(r=>r.id===payload);
    if (!r) return;
    orthoDrag.r0 = { x:r.x, y:r.y };
  }
  if (kind==="zone"){
    const z = layout.zones.find(z=>z.id===payload);
    if (!z) return;
    orthoDrag.poly0 = z.poly.map(p=>({x:p.x,y:p.y}));
    orthoDrag.racks0 = layout.racks.filter(r=>r.zone===payload).map(r=>({id:r.id,x:r.x,y:r.y}));
  }
  if (kind==="vtx"){
    const z = layout.zones.find(z=>z.id===payload.zoneId);
    if (!z) return;
    orthoDrag.v0 = { x:z.poly[payload.idx].x, y:z.poly[payload.idx].y };
  }

  orthoMap.setPointerCapture(ev.pointerId);
}

orthoMap.addEventListener("pointermove",(ev)=>{
  if (!orthoDragging || !orthoDrag) return;
  const p = getSVGPoint(orthoMap, ev);
  const dx = p.x - orthoDrag.start.x;
  const dy = p.y - orthoDrag.start.y;
  if (Math.hypot(dx,dy) > 0.08) orthoDrag.moved = true;

  if (orthoDrag.kind==="rack"){
    const r = layout.racks.find(r=>r.id===orthoDrag.payload);
    if (!r) return;
    r.x = snapM(orthoDrag.r0.x + dx);
    r.y = snapM(orthoDrag.r0.y + dy);
    drawAlignmentGuides(orthoMap, {x:r.x, y:r.y});
    drawIsometric();
    renderOrthoThrottled();
    return;
  }

  if (orthoDrag.kind==="zone"){
    const z = layout.zones.find(z=>z.id===orthoDrag.payload);
    if (!z) return;
    const sx = snapM(dx);
    const sy = snapM(dy);
    z.poly = orthoDrag.poly0.map(q=>({x:q.x+sx,y:q.y+sy}));
    for (const r0 of orthoDrag.racks0){
      const rr = layout.racks.find(r=>r.id===r0.id);
      if (rr){
        rr.x = snapM(r0.x + sx);
        rr.y = snapM(r0.y + sy);
      }
    }
    drawAlignmentGuides(orthoMap, centroid(z.poly));
    drawIsometric();
    renderOrthoThrottled();
    return;
  }

  if (orthoDrag.kind==="vtx"){
    const { zoneId, idx } = orthoDrag.payload;
    const z = layout.zones.find(z=>z.id===zoneId);
    if (!z) return;
    let np = { x: orthoDrag.v0.x + dx, y: orthoDrag.v0.y + dy };
    np = snapPt(np);
    np = alignSnapPoint(np, zoneId, 0.20);
    z.poly[idx] = np;
    drawAlignmentGuides(orthoMap, np);
    drawIsometric();
    renderOrthoThrottled();
  }
});

orthoMap.addEventListener("pointerup",()=>{
  if (!orthoDragging || !orthoDrag) return;
  orthoDragging = false;
  if (orthoDrag.moved){
    pushHistory("ortho drag");
    saveLayout();
    feedbackOK();
  }
  orthoDrag = null;
});

orthoMap.addEventListener("pointercancel",()=>{
  orthoDragging=false; orthoDrag=null;
});

/* =========================
   Zone Modal Editor (per-zone)
========================= */
let ZM_OPEN = false;
let ZM_ZONE_ID = null;
let zmDraft = null;
let ZM_SHOW_DIMS = false;
let ZM_SHOW_RACKS = true;
let zmDragging = false;
let zmDrag = null;
const zmHist = { stack:[], idx:-1 };

function zmPush(label){
  const snap = JSON.stringify({ draft: zmDraft, label, t:Date.now() });
  zmHist.stack = zmHist.stack.slice(0, zmHist.idx+1);
  zmHist.stack.push(snap);
  zmHist.idx++;
}
function zmUndo(){
  if (zmHist.idx <= 0) return;
  zmHist.idx--;
  const st = JSON.parse(zmHist.stack[zmHist.idx]);
  zmDraft = JSON.parse(JSON.stringify(st.draft));
  renderZoneModal();
}
function zmRedo(){
  if (zmHist.idx >= zmHist.stack.length-1) return;
  zmHist.idx++;
  const st = JSON.parse(zmHist.stack[zmHist.idx]);
  zmDraft = JSON.parse(JSON.stringify(st.draft));
  renderZoneModal();
}

function openZoneEditor(zoneId){
  const z = layout.zones.find(zz => zz.id === zoneId);
  if (!z) return;

  ZM_OPEN = true;
  ZM_ZONE_ID = zoneId;

  zmDraft = {
    zone: JSON.parse(JSON.stringify(z)),
    racks: JSON.parse(JSON.stringify(layout.racks))
  };

  zmHist.stack = [];
  zmHist.idx = -1;
  zmPush("open");

  zoneModal.setAttribute("aria-hidden", "false");
  zoneModalSub.textContent = `Zona seleccionada: ${zoneId} ‚Ä¢ Editor dedicado`;
  updateZoneMiniInfo();
  renderZoneModal();
}

function closeZoneEditor(){
  ZM_OPEN = false;
  ZM_ZONE_ID = null;
  zmDraft = null;
  zoneModal.setAttribute("aria-hidden", "true");
}

function updateZoneMiniInfo(){
  zoneMiniInfo.textContent = `Modo: ${zoneTool.value} ‚Ä¢ Snap: ${zoneSnap.value}m ‚Ä¢ Align: ${zoneAlign.value}m`;
}

zoneModalBackdrop.addEventListener("click", closeZoneEditor);
zoneModalCloseBtn.addEventListener("click", closeZoneEditor);
document.addEventListener("keydown", (e)=>{
  if (!ZM_OPEN) return;
  if (e.key === "Escape") closeZoneEditor();
});

zoneToggleDims.addEventListener("click", ()=>{
  ZM_SHOW_DIMS = !ZM_SHOW_DIMS;
  zoneToggleDims.textContent = ZM_SHOW_DIMS ? "üìè Cotas: ON" : "üìè Cotas: OFF";
  renderZoneModal();
});
zoneToggleRacks.addEventListener("click", ()=>{
  ZM_SHOW_RACKS = !ZM_SHOW_RACKS;
  zoneToggleRacks.textContent = ZM_SHOW_RACKS ? "üß± Estantes: ON" : "üß± Estantes: OFF";
  renderZoneModal();
});

zoneUndoBtn.addEventListener("click", zmUndo);
zoneRedoBtn.addEventListener("click", zmRedo);

zoneTool.addEventListener("change", ()=>{ updateZoneMiniInfo(); renderZoneModal(); });
zoneSnap.addEventListener("change", ()=> updateZoneMiniInfo());
zoneAlign.addEventListener("change", ()=> updateZoneMiniInfo());

zoneApply.addEventListener("click", ()=>{
  if (!ZM_OPEN || !zmDraft) return;

  const idx = layout.zones.findIndex(z => z.id === ZM_ZONE_ID);
  if (idx >= 0){
    layout.zones[idx] = JSON.parse(JSON.stringify(zmDraft.zone));
  }

  pushHistory("apply zone modal");
  saveLayout();
  refreshAllRenders(true);
  feedbackOK();
  closeZoneEditor();
});

zoneCancel.addEventListener("click", closeZoneEditor);

function zmSnapM(n){
  const s = parseFloat(zoneSnap.value);
  if (!s || s<=0) return n;
  return Math.round(n / s) * s;
}
function zmSnapPt(p){ return { x: zmSnapM(p.x), y: zmSnapM(p.y) }; }

function zmApplyAlign(p, excludeZoneId){
  const a = parseFloat(zoneAlign.value);
  if (!a || a<=0) return p;
  return alignSnapPoint(p, excludeZoneId, a);
}

function zoneViewBoxFor(poly){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for (const p of poly){
    minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
    maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
  }
  const pad = 6;
  return { x:minX-pad, y:minY-pad, w:(maxX-minX)+pad*2, h:(maxY-minY)+pad*2 };
}

function zmInsertVertex(clickPt){
  const z = zmDraft?.zone;
  if (!z || z.poly.length < 3) return;

  const hit = nearestEdge(z.poly, clickPt);
  if (hit.d > 1.15) return;

  let np = zmSnapPt(hit.proj);
  np = zmApplyAlign(np, z.id);
  z.poly.splice(hit.i+1, 0, np);

  zmPush("add vertex");
  renderZoneModal();
}

function renderZoneModal(){
  if (!ZM_OPEN || !zmDraft) return;

  const z = zmDraft.zone;
  const vb = zoneViewBoxFor(z.poly);
  zoneMap.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
  zoneMap.innerHTML = "";

  const isDark = document.body.classList.contains("dark");
  zoneMap.appendChild(svgEl("rect",{x:vb.x,y:vb.y,width:vb.w,height:vb.h,rx:2,fill: isDark ? "#0b1220":"#ffffff"}));

  const path = svgEl("path",{ d: polyToPath(z.poly), class:"ortho-zone selected" });
  zoneMap.appendChild(path);

  const edgeHit = svgEl("path",{ d: polyToPath(z.poly), class:"edge-hit" });
  edgeHit.addEventListener("click",(ev)=>{
    if (zoneTool.value !== "add-vertex") return;
    ev.preventDefault(); ev.stopPropagation();
    const pt = zmSnapPt(getSVGPoint(zoneMap, ev));
    zmInsertVertex(pt);
  });
  zoneMap.appendChild(edgeHit);

  if (ZM_SHOW_DIMS){
    try{ drawEdgeDimsForPoly(zoneMap, z.poly); }catch(e){}
  }

  if (ZM_SHOW_RACKS){
    const gR = svgEl("g",{});
    for (const r of zmDraft.racks){
      if (r.zone !== z.id) continue;
      gR.appendChild(svgEl("rect",{x:r.x,y:r.y,width:r.w,height:r.d,rx:0.4,class:"ortho-rack"}));
    }
    zoneMap.appendChild(gR);
  }

  const VTX_HIT_R = 2.6;
  const VTX_VISIBLE_R = 1.15;

  z.poly.forEach((p, idx)=>{
    const hit = svgEl("circle",{ cx:p.x, cy:p.y, r:VTX_HIT_R, class:"vtx-hit", "data-idx":idx });
    const c = svgEl("circle",{ cx:p.x, cy:p.y, r:VTX_VISIBLE_R, class:"vtx", "data-idx":idx });

    const down = (ev)=>{
      ev.preventDefault(); ev.stopPropagation();

      if (zoneTool.value === "del-vertex"){
        if (z.poly.length <= 3) return;
        z.poly.splice(idx,1);
        zmPush("del vertex");
        renderZoneModal();
        return;
      }

      if (zoneTool.value !== "vtx-move") return;

      zmDragging = true;
      const start = getSVGPoint(zoneMap, ev);
      zmDrag = { kind:"vtx", idx, start, p0:{x:p.x,y:p.y}, moved:false };
      zoneMap.setPointerCapture(ev.pointerId);
    };

    hit.addEventListener("pointerdown", down);
    c.addEventListener("pointerdown", down);

    zoneMap.appendChild(hit);
    zoneMap.appendChild(c);
  });

  path.addEventListener("pointerdown",(ev)=>{
    if (zoneTool.value !== "move-zone") return;
    ev.preventDefault(); ev.stopPropagation();
    zmDragging = true;
    const start = getSVGPoint(zoneMap, ev);
    zmDrag = { kind:"zone", start, poly0: z.poly.map(q=>({x:q.x,y:q.y})), moved:false };
    zoneMap.setPointerCapture(ev.pointerId);
  });

  const c = centroid(z.poly);
  const t = svgEl("text",{ x:c.x, y:c.y, "text-anchor":"middle", "font-size":"2.6", "font-weight":"900", "font-family":"monospace",
    fill: isDark ? "rgba(148,163,184,.85)" : "rgba(17,24,39,.55)" });
  t.textContent = z.id;
  zoneMap.appendChild(t);
}

zoneMap.addEventListener("pointermove",(ev)=>{
  if (!zmDragging || !zmDrag || !zmDraft) return;
  const z = zmDraft.zone;
  const p = getSVGPoint(zoneMap, ev);

  if (zmDrag.kind === "vtx"){
    const dx = p.x - zmDrag.start.x;
    const dy = p.y - zmDrag.start.y;
    if (Math.hypot(dx,dy) > 0.35) zmDrag.moved = true;

    let np = { x: zmDrag.p0.x + dx, y: zmDrag.p0.y + dy };
    np = zmSnapPt(np);
    np = zmApplyAlign(np, z.id);

    z.poly[zmDrag.idx] = np;
    renderZoneModal();
    return;
  }

  if (zmDrag.kind === "zone"){
    const dx = p.x - zmDrag.start.x;
    const dy = p.y - zmDrag.start.y;
    if (Math.hypot(dx,dy) > 0.35) zmDrag.moved = true;

    const dxS = zmSnapM(dx);
    const dyS = zmSnapM(dy);

    let moved = zmDrag.poly0.map(q=>({ x:q.x+dxS, y:q.y+dyS }));

    const cx = moved.reduce((a,q)=>a+q.x,0)/moved.length;
    const cy = moved.reduce((a,q)=>a+q.y,0)/moved.length;
    const c2 = zmApplyAlign({x:cx,y:cy}, z.id);
    const ax = c2.x - cx;
    const ay = c2.y - cy;
    moved = moved.map(q=>({x:q.x+ax,y:q.y+ay}));

    z.poly = moved;
    renderZoneModal();
  }
});

zoneMap.addEventListener("pointerup",()=>{
  if (!zmDragging) return;
  zmDragging = false;
  if (zmDrag?.moved) zmPush("drag");
  zmDrag = null;
});
zoneMap.addEventListener("pointercancel",()=>{ zmDragging=false; zmDrag=null; });

/* open zone modal button */
btnEditZoneModal.addEventListener("click", ()=>{
  if (APP_MODE!=="editor" || !EDIT_MODE) return;
  let zoneId = null;
  if (selected.type==="zone" && selected.id) zoneId = selected.id;
  else if (resultadosActuales.length){
    const filaActiva = resultadosActuales[indiceActual];
    const activo = (modo === "reducido" && filaActiva._representante) ? filaActiva._representante : filaActiva;
    zoneId = activo?.mainLoc?.zonaId || null;
  }
  if (!zoneId) zoneId = "Z1";
  openZoneEditor(zoneId);
});

/* =========================
   Refresh all renders
========================= */
function refreshAllRenders(playFeedback=false){
  drawIsometric();
  if (ORTHO_ON) renderOrtho();
  applySelectionHighlight();
  if (resultadosActuales.length) aplicarResultadoActivo(false);
  if (playFeedback) feedbackOK();
}

/* =========================
   Start: default viewer
========================= */
setAppMode("viewer");
setTool("select");
setEditModeUI();

/* Ensure isometric exists even before sheet loads */
refreshAllRenders(false);
</script>

</body>
</html>
